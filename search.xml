<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Thoughts</title>
    <url>/posts/5e06a6f0/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>glm4.5V要结束了</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmF4dWFuL1p0b0FwaQ==">https://github.com/libaxuan/ZtoApi<i class="fa fa-external-link-alt"></i></span></p>
<p>研究hugging face</p>
<p>用函数调用api试试。。。。 <span class="exturl" data-url="aHR0cHM6Ly9iYWlsaWFuLmNvbnNvbGUuYWxpeXVuLmNvbS8/c3BtPTUxNzYuMjk1OTc5MTguSl9TRXNTanNOdjcyeVJ1UkZTMlZrbk8uMi41YTYzN2IwOGVLUFZHUyZ0YWI9bW9kZWwjL21vZGVsLW1hcmtldD9jYXBhYmlsaXRpZXM9JTVCJTIyQVNSJTIyJTVEJnpfdHlwZV89JTdCJTIyY2FwYWJpbGl0aWVzJTIyJTNBJTIyYXJyYXklMjIlN0Q=">阿里的<i class="fa fa-external-link-alt"></i></span><br>qwen-audio-turbo-latest<br>qwen-omni-turbo-realtime-latest</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5tb29uc2hvdC5jbi9wbGF5Z3JvdW5k">https://platform.moonshot.cn/playground<i class="fa fa-external-link-alt"></i></span></p>
<p>谷歌的deep research 是怎么设置提示词的？</p>
<img src = "https://media.makomako.dpdns.org/avatar/avatar.jpg" style= "width: auto ">

]]></content>
      <categories>
        <category>AI &amp; LLM</category>
        <category>Interesting</category>
      </categories>
  </entry>
  <entry>
    <title>高粱米博客的 AI 聊天系统实战：从零到稳定</title>
    <url>/posts/bfdcb374/</url>
    <content><![CDATA[<p>这是一篇记录从零打造并稳定上线「高粱米 AI 姐姐」聊天系统的实战总结。项目基于 Hexo + NexT，前端纯静态，通过 Cloudflare Workers 作为安全代理完成与 OpenAI 兼容接口的对接。</p>
<h2 id="目标与约束"><a href="#目标与约束" class="headerlink" title="目标与约束"></a>目标与约束</h2><ul>
<li>前端纯静态，不暴露任何密钥</li>
<li>流式输出、连续对话、轻量 UI</li>
<li>具备速率限制和来源校验，防滥用</li>
<li>GitHub Pages 自动部署，故障可快速回滚</li>
</ul>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul>
<li>前端：<code>source/js/chat.js</code><ul>
<li>通过 <code>STATE.globalConfig.proxyUrl</code> 统一指向 Worker 代理</li>
<li>两条路径：非流式与流式（SSE），均走代理</li>
<li>本地开发：推荐使用 <code>wrangler dev</code> 启动本地 Workers 代理；前端不再注入 API Key（不再支持直连）</li>
</ul>
</li>
<li>代理：Cloudflare Worker <code>chat-proxy</code><ul>
<li>环境变量：<code>CHAT_API_KEY</code>、<code>ALLOWED_ORIGINS</code></li>
<li>速率限制（KV 可选）：每小时&#x2F;每日</li>
<li>CORS 处理，阻断非白名单来源</li>
<li>仅允许受控 model 列表</li>
</ul>
</li>
</ul>
<h2 id="核心演进与坑点"><a href="#核心演进与坑点" class="headerlink" title="核心演进与坑点"></a>核心演进与坑点</h2><ol>
<li>代理地址与优先级</li>
</ol>
<ul>
<li>现象：控制台仍然请求旧域名</li>
<li>根因：PJAX + 浏览器缓存 + localStorage 旧配置覆盖</li>
<li>方案：代码优先使用 <code>global.proxyUrl</code>，并给 <code>chat.js</code> 增加版本号参数强制刷新</li>
</ul>
<ol start="2">
<li>Service Worker 安装失败</li>
</ol>
<ul>
<li>现象：<code>addAll</code> 404、<code>installing worker became redundant</code></li>
<li>根因：GitHub Pages 上的路径不一，预缓存名单失配</li>
<li>方案：更换为极简透传 SW（只 skipWaiting&#x2F;clients.claim，不做缓存拦截）</li>
</ul>
<ol start="3">
<li>UI 可拖拽“漂移”</li>
</ol>
<ul>
<li>现象：入口气泡可被拖到奇怪位置、记忆后影响体验</li>
<li>方案：默认关闭拖拽（<code>entryBubbleDraggable: false</code>），需要时再手动开启</li>
</ul>
<ol start="4">
<li>CORS 与来源校验</li>
</ol>
<ul>
<li>现象：<code>Failed to fetch</code> &#x2F; <code>Origin not allowed</code></li>
<li>方案：Worker 中检查 <code>Origin</code> 是否包含 <code>https://zhu-jl18.github.io</code>（或其它白名单），OPTIONS 预检返回 200 + CORS 头</li>
</ul>
<ol start="5">
<li>清理废弃的 API Base &#x2F; API Key 前端配置</li>
</ol>
<ul>
<li>现象：设置面板里仍能看到 API Base &#x2F; API Key，但实际请求已统一走 Worker 代理<ul>
<li>方案：移除前端的 API Base &#x2F; API Key 字段与本地直连逻辑（<code>CHAT_LOCAL_*</code>），统一使用 <code>proxyUrl</code>；<code>chat.js</code> 已精简设置面板为仅选择模型</li>
</ul>
</li>
</ul>
<h2 id="本地开发与测试（统一代理）"><a href="#本地开发与测试（统一代理）" class="headerlink" title="本地开发与测试（统一代理）"></a>本地开发与测试（统一代理）</h2><ul>
<li><p>前置环境</p>
<ul>
<li>启动 Hexo 本地服务（默认 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw77yJ77ya">http://localhost:4000）：<i class="fa fa-external-link-alt"></i></span><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure></li>
<li>启动 Cloudflare Worker 本地代理（默认 <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo4Nzg377yJ77ya">http://127.0.0.1:8787）：<i class="fa fa-external-link-alt"></i></span><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> cloudflare-worker</span><br><span class="line">wrangler dev</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>指定本地代理地址（两选一）</p>
<ul>
<li>使用浏览器控制台设置持久覆盖（推荐）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;chat-proxy-override&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8787&#x27;</span>);</span><br><span class="line">location.<span class="title function_">reload</span>();</span><br></pre></td></tr></table></figure></li>
<li>临时变量（刷新后失效）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">CHAT_PROXY_DEV</span> = <span class="string">&#x27;http://127.0.0.1:8787&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>验证</p>
<ul>
<li>打开网页 → 开发者工具 → Network，确认聊天请求发往 <code>127.0.0.1:8787</code>。</li>
<li>代理会校验 <code>Origin</code>。当前 <code>chat-proxy.js</code> 默认允许 <code>localhost:4000/127.0.0.1:4000</code>；若需更严格控制，可在 Cloudflare Dashboard 的 <code>ALLOWED_ORIGINS</code> 中显式加入本地地址。</li>
<li>预检（OPTIONS）应返回 200，并带有 CORS 头（见 <code>handleCORS()</code>）。</li>
</ul>
</li>
<li><p>恢复生产代理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;chat-proxy-override&#x27;</span>);</span><br><span class="line">location.<span class="title function_">reload</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="部署与回滚"><a href="#部署与回滚" class="headerlink" title="部署与回滚"></a>部署与回滚</h2><ul>
<li>分支：<code>develop</code> 开发 → PR → <code>main</code> 自动部署（GitHub Actions）</li>
<li>缓存处置：新版本发布后，给关键脚本带版本号；必要时在浏览器 DevTools 中清理 SW 与缓存</li>
<li>回滚：强制推送 <code>main</code> 到上一稳定提交（紧急时使用）</li>
</ul>
<h2 id="速查清单"><a href="#速查清单" class="headerlink" title="速查清单"></a>速查清单</h2><ul>
<li>Worker 环境变量：<ul>
<li><code>CHAT_API_KEY</code>：真实 API Key</li>
<li><code>ALLOWED_ORIGINS</code>：<code>https://zhu-jl18.github.io</code></li>
</ul>
</li>
<li>快速探活：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I https://chat-proxy.nontrivial2025.workers.dev</span><br></pre></td></tr></table></figure></li>
<li>前端清本地配置：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;chatcfg.v2&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>常见报错：<ul>
<li><code>ERR_BLOCKED_BY_CLIENT</code>：被广告拦截插件拦截，非功能性错误</li>
<li>SW 404：使用极简 SW；若安装失败，先 Unregister 再刷新</li>
<li>仍走旧域名：确认脚本已带版本号、清理缓存</li>
</ul>
</li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul>
<li>开发：Mako &amp; Cascade（级联的含义是把复杂问题拆成有序步骤，像瀑布一样推进）</li>
<li>特别感谢每次“线上 real-time 排障”的耐心与果断，这个系统在不断打磨中变得越来越稳。</li>
</ul>
]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp;&amp; LLM</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>Hexo</tag>
        <tag>Cloudflare Workers</tag>
        <tag>CORS</tag>
        <tag>Service Worker</tag>
        <tag>PJAX</tag>
        <tag>部署排错</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客构建专业级图片加速与自动化工作流：一份面向未来的实践指南</title>
    <url>/posts/82239bef/</url>
    <content><![CDATA[<blockquote>
<p> 使用gemini-2.5-pro 的deep research 功能生成的指南，已按照指南成功迁移</p>
</blockquote>
<span id="more"></span>
<hr>
<h2 id="引言：从”不方便”到专业的发布工作流"><a href="#引言：从”不方便”到专业的发布工作流" class="headerlink" title="引言：从”不方便”到专业的发布工作流"></a>引言：从”不方便”到专业的发布工作流</h2><p>对于使用 Hexo 等静态站点生成器构建个人博客或文档网站的创作者而言，一个普遍的认知是：将网站代码（Hexo 项目本身）与媒体资产（尤其是图片）分离，是实现卓越网络性能的基础原则。将所有图片资源直接存储在主站点的 Git 仓库中，会导致仓库体积迅速膨胀，进而拖慢 git clone 和 git pull 的速度，并显著延长持续集成&#x2F;持续部署（CI&#x2F;CD）的构建与部署时间，最终损害访问者的加载体验。</p>
<p>用户当前采用的 GitHub + jsDelivr 方案，本质上是对一种专业架构的模拟，虽然在一定程度上解决了加载速度问题，但其”不方便”的操作流程暴露了其作为临时变通方案的局限性。用户所寻求的”图片加速服务”，在专业领域中，通常指代一个由两个核心组件构成的健壮架构：一个用于存储静态资源的集中式、可扩展的**对象存储（Object Storage）作为”源站”，以及一个在全球范围内部署的内容分发网络（Content Delivery Network, CDN）**用于高速分发。</p>
<p>本报告旨在提供一份详尽、可执行且面向未来的指南，旨在帮助用户从当前的工作流平稳过渡到一个无缝、自动化且性能卓越的现代化媒体资产管理体系。该体系不仅能解决当前的”不方便”问题，还能为个人网站的长期发展奠定一个成本可控、高度可扩展且专业化的坚实基础。</p>
<h2 id="第一部分：性能架构的基石：为何必须解耦代码与内容"><a href="#第一部分：性能架构的基石：为何必须解耦代码与内容" class="headerlink" title="第一部分：性能架构的基石：为何必须解耦代码与内容"></a>第一部分：性能架构的基石：为何必须解耦代码与内容</h2><p>本部分将深入阐释我们推荐架构背后的核心理念，分析将媒体文件存储于 Git 仓库中的技术局限性，并介绍解决这些问题的行业标准组件。</p>
<h3 id="1-1-将-Git-仓库作为媒体存储的反模式"><a href="#1-1-将-Git-仓库作为媒体存储的反模式" class="headerlink" title="1.1 将 Git 仓库作为媒体存储的反模式"></a>1.1 将 Git 仓库作为媒体存储的反模式</h3><p>Git 作为一个分布式版本控制系统，其核心设计目标是高效追踪基于文本的源代码的逐行变化，而非作为一个通用的文件托管服务。将图片等二进制文件存储在 Git 仓库中，是一种典型的”反模式”，会引发一系列性能问题：</p>
<p><strong>仓库膨胀效应</strong>：与文本文件不同，Git 无法对二进制文件进行有效的”差异比较”（diffing）。这意味着即使对图片进行微小的修改（例如，裁剪或调整亮度），Git 也必须存储一个全新的、完整的二进制文件副本。随着时间推移，这将导致仓库体积呈指数级增长。</p>
<p><strong>开发工作流性能下降</strong>：一个臃肿的仓库会直接影响开发效率。对于任何协作者而言，执行 git clone 和 git pull 操作都将变得异常缓慢。更重要的是，在自动化部署流程中（例如通过 GitHub Pages, Netlify 或 Vercel），构建服务器必须检出整个庞大的仓库，这会极大地延长构建和部署时间。</p>
<p><strong>平台局限性与风险</strong>：虽然用户当前的方案通过 jsDelivr 卸载了图片的最终分发，但其将 GitHub 作为媒体源的做法本身存在缺陷。GitHub 并非为大规模媒体托管而设计，存在速率限制和文件大小限制，其服务条款通常也禁止将其用作通用的媒体托管服务。</p>
<h3 id="1-2-现代范式：将对象存储作为媒体资产库"><a href="#1-2-现代范式：将对象存储作为媒体资产库" class="headerlink" title="1.2 现代范式：将对象存储作为媒体资产库"></a>1.2 现代范式：将对象存储作为媒体资产库</h3><p>对象存储是专为存储海量非结构化数据（如图片、视频、日志和备份文件）而设计的现代存储架构。我们可以将其比作一个”数据的代客泊车系统”或一个”没有货架的无限仓库”，它通过一种截然不同的方式来组织和访问数据。其核心特性包括：</p>
<p><strong>扁平化结构</strong>：与传统文件系统（File Storage）的层级式文件夹结构不同，对象存储采用扁平的地址空间。每个文件（或称”对象”）都存在于同一个层级，通过一个全局唯一的标识符（Key）进行访问。这种设计避免了因遍历深层目录结构而带来的性能瓶颈。</p>
<p><strong>丰富的元数据</strong>：每个对象都可以附加大量可自定义的元数据标签。这远比传统文件系统有限的元数据（如文件名、创建日期）要强大得多，为数据管理、分类和检索提供了极大的灵活性。</p>
<p><strong>大规模可扩展性</strong>：对象存储从设计之初就考虑到了海量数据的存储需求，能够轻松扩展至 PB（千万亿字节）甚至 EB（百亿亿字节）级别。对于个人博客而言，这意味着存储空间永远不会成为发展的瓶颈。</p>
<p><strong>原生 API 访问</strong>：对象通过标准的 HTTP API（如 RESTful API）进行访问，这使其天然地适合作为 Web 应用的后端存储，易于与各种应用程序和工具集成。</p>
<h3 id="1-3-全球触达：内容分发网络（CDN）的关键作用"><a href="#1-3-全球触达：内容分发网络（CDN）的关键作用" class="headerlink" title="1.3 全球触达：内容分发网络（CDN）的关键作用"></a>1.3 全球触达：内容分发网络（CDN）的关键作用</h3><p>物理距离是网络延迟的主要来源。当一个位于亚洲的用户访问部署在北美的服务器时，数据传输的物理延迟是无法避免的。CDN 正是为解决这一问题而生。</p>
<p>CDN 是一个在全球范围内部署的、由大量服务器组成的分布式网络。它通过在靠近用户的地方缓存您网站的静态资产（如图片）的副本来工作。当用户请求一张图片时，该请求会被智能地路由到离他最近的 CDN “存在节点”（Point of Presence, PoP），并由该节点直接提供服务。这极大地缩短了数据传输距离，从而显著降低了加载时间。</p>
<p>除了加速，CDN 还提供了极高的可靠性和弹性。诸如 jsDelivr 和 Cloudflare 等领先的 CDN 服务商，通常会使用多个底层供应商（Multi-CDN），这意味着即使某个供应商的网络出现故障，流量也会被自动重新路由到其他健康的供应商，从而确保服务的高可用性。</p>
<h3 id="1-4-协同架构：对象存储-CDN-的黄金组合"><a href="#1-4-协同架构：对象存储-CDN-的黄金组合" class="headerlink" title="1.4 协同架构：对象存储 + CDN 的黄金组合"></a>1.4 协同架构：对象存储 + CDN 的黄金组合</h3><p>将对象存储与 CDN 结合，构成了现代 Web 资产分发的标准蓝图。在这个架构中：</p>
<ul>
<li><strong>对象存储</strong> 扮演着”源站”（Origin）的角色。它是所有媒体资产的唯一、权威的存储中心。</li>
<li><strong>CDN</strong> 则作为面向全球用户的”缓存加速层”。</li>
</ul>
<p>其工作流程如下：当某个地区的第一个用户请求一张图片时，CDN 节点会从后端的对象存储源站拉取该图片，将其交付给用户的同时，在自己的缓存中保留一个副本。当同一地区的其他用户再次请求同一张图片时，CDN 将直接从其本地缓存中提供，无需再回溯到源站。这个过程不仅速度极快，还大大减轻了源站的负载压力。</p>
<p>用户当前的 GitHub + jsDelivr 方案，实际上是在用 GitHub 模拟”源站”，用 jsDelivr 作为”缓存加速层”。这个架构思路是正确的，但其”源站”的选择存在根本性的缺陷。本报告的核心目标，正是指导用户将这个有缺陷的组件替换为专为此目的而设计的、更专业、更可靠的”对象存储”服务。</p>
<h2 id="第二部分：解决方案评估：为个人-Hexo-站点选择最佳平台"><a href="#第二部分：解决方案评估：为个人-Hexo-站点选择最佳平台" class="headerlink" title="第二部分：解决方案评估：为个人 Hexo 站点选择最佳平台"></a>第二部分：解决方案评估：为个人 Hexo 站点选择最佳平台</h2><p>本部分将从理论转向实践，客观评估用户当前方案的利弊，并基于数据和技术趋势，论证为何 Cloudflare R2 是当前个人博客及文档类网站的最佳选择。</p>
<h3 id="2-1-解构当前方案：GitHub-jsDelivr"><a href="#2-1-解构当前方案：GitHub-jsDelivr" class="headerlink" title="2.1 解构当前方案：GitHub + jsDelivr"></a>2.1 解构当前方案：GitHub + jsDelivr</h3><p>在选择新方案之前，有必要公正地评估现有方案。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>完全免费</strong>：该方案不产生任何存储或带宽费用。</li>
<li><strong>卓越的性能与可靠性</strong>：jsDelivr 是一个高质量的 Multi-CDN 服务，其后端整合了 Cloudflare 和 Fastly 等顶级网络，提供了出色的全球访问速度和极高的正常运行时间。</li>
<li><strong>永久缓存</strong>：jsDelivr 的一个显著特性是其永久缓存机制。即使原始的 GitHub 仓库被删除，只要文件曾被 jsDelivr 缓存，它就会永久地提供服务，避免了因源站问题导致的图片链接失效。</li>
</ul>
<p><strong>致命缺陷</strong>：</p>
<ul>
<li><strong>违反服务条款</strong>：将 GitHub 和 jsDelivr 用作个人博客的大容量、通用媒体托管服务，实际上是对其服务宗旨的滥用。尽管这种用法在小型开源项目中被普遍容忍，但它随时可能受到限制或被禁止，这为网站的长期稳定运营带来了不可控的平台风险。</li>
<li><strong>繁琐的工作流程</strong>：正如用户所指出的，需要手动将图片提交到另一个独立的 Git 仓库，然后手动构建 URL，这个过程打断了写作的连贯性，效率低下。</li>
<li><strong>硬性限制</strong>：jsDelivr 对单个文件（最大 20MB）和单个仓库（最大 150MB）的大小有限制。对于需要托管高分辨率图片、视频或其他大型文件的场景，这可能成为一个无法逾越的障碍。</li>
</ul>
<h3 id="2-2-2024-年及未来的首选方案：Cloudflare-R2"><a href="#2-2-2024-年及未来的首选方案：Cloudflare-R2" class="headerlink" title="2.2 2024 年及未来的首选方案：Cloudflare R2"></a>2.2 2024 年及未来的首选方案：Cloudflare R2</h3><p>Cloudflare R2 是一个专为现代开发者和内容创作者设计的对象存储服务，它精准地解决了传统云存储的痛点，使其成为个人项目的理想选择。其核心优势体现在以下三个方面：</p>
<p><strong>S3 兼容性</strong>：R2 提供了与 Amazon S3 完全兼容的 API 接口。S3 API 是事实上的行业标准，这意味着为 S3 开发的庞大工具、库和插件生态系统（包括我们稍后将推荐的 PicGo 插件）都可以无缝地与 R2 协同工作。这极大地降低了技术采用的门槛和风险。</p>
<p><strong>慷慨的免费额度</strong>：R2 每月提供 10 GB 的免费存储空间、100 万次 A 类操作（写入、修改等）和 1000 万次 B 类操作（读取）。对于绝大多数个人博客和文档网站而言，这个额度足以覆盖日常使用而无需支付任何费用。</p>
<p><strong>颠覆性的”零出口流量费用”</strong>：这是 R2 最具革命性的优势。传统的云存储提供商（如 AWS、阿里云、腾讯云）都会对数据从其服务器传输到互联网的行为收取”出口流量费”（Egress Fees）。对于博客而言，用户的每一次图片浏览都构成一次出口流量。随着网站访问量的增长，这笔费用可能会变得非常高昂且难以预测。Cloudflare R2 则完全免除了这笔费用，出口流量费为零。</p>
<p>这种定价模式的转变，根本上改变了内容创作者与平台之间的关系。在传统模式下，网站的成功（高流量）会带来惩罚性的成本增长。而在 R2 的模式下，创作者可以放心地吸引更多访客，而不必担心流量成本失控。这种商业模式上的根本性对齐，是选择 R2 而非其他竞争对手的强有力战略理由。</p>
<h3 id="2-3-市场格局：主流对象存储服务对比"><a href="#2-3-市场格局：主流对象存储服务对比" class="headerlink" title="2.3 市场格局：主流对象存储服务对比"></a>2.3 市场格局：主流对象存储服务对比</h3><p>为了更直观地展示 R2 的优势，下表对主流云服务商的对象存储服务进行了关键指标的对比，重点关注个人及小型项目的需求。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Cloudflare R2</th>
<th>AWS S3</th>
<th>阿里云 OSS</th>
<th>腾讯云 COS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>免费存储额度</strong></td>
<td>10 GB&#x2F;月</td>
<td>5 GB (12 个月免费试用)</td>
<td>5 GB (LRS, 永久免费)</td>
<td>50 GB (标准存储, 6 个月免费)</td>
</tr>
<tr>
<td><strong>免费写入操作</strong></td>
<td>100 万次 A 类&#x2F;月</td>
<td>2,000 次&#x2F;月 (12 个月)</td>
<td>因套餐而异</td>
<td>100 万次&#x2F;月 (6 个月)</td>
</tr>
<tr>
<td><strong>免费读取操作</strong></td>
<td>1,000 万次 B 类&#x2F;月</td>
<td>20,000 次&#x2F;月 (12 个月)</td>
<td>因套餐而异</td>
<td>1,000 万次&#x2F;月 (6 个月)</td>
</tr>
<tr>
<td><strong>超出额度存储成本 (约&#x2F;GB&#x2F;月)</strong></td>
<td>$0.015</td>
<td>$0.023</td>
<td>$0.0173</td>
<td>$0.024</td>
</tr>
<tr>
<td><strong>出口流量费 (约&#x2F;GB)</strong></td>
<td><strong>$0.00 (无)</strong></td>
<td>$0.09</td>
<td>$0.07+</td>
<td>$0.10</td>
</tr>
<tr>
<td><strong>核心差异点</strong></td>
<td>无出口流量费</td>
<td>市场领导者，生态最成熟</td>
<td>亚太地区覆盖广</td>
<td>亚太地区覆盖广</td>
</tr>
</tbody></table>
<p>此表格清晰地表明，尽管各家厂商都提供一定的免费额度，但在最关键的”出口流量费”一项上，Cloudflare R2 具有无可比拟的优势，使其成为个人内容网站最具成本效益和可预测性的选择。</p>
<p>对于位于亚洲或主要读者群体在亚洲的用户，选择一个在亚太地区（APAC）性能优异的服务至关重要。虽然阿里云和腾讯云在该地区拥有强大的基础设施，但 Cloudflare 同样在亚太地区投入巨资建设其网络。然而，也存在社区报告指出 R2 在亚太地区的性能偶尔会出现波动。因此，一个更为审慎和专业的建议是：在创建 R2 存储桶（Bucket）时，明确指定”位置提示”（Location Hint）为亚太地区（例如 apac），以最大化地优化访问性能，同时对可能出现的性能波动保持合理的预期。</p>
<h2 id="第三部分：工作流自动化：借助-PicGo-实现无缝衔接"><a href="#第三部分：工作流自动化：借助-PicGo-实现无缝衔接" class="headerlink" title="第三部分：工作流自动化：借助 PicGo 实现无缝衔接"></a>第三部分：工作流自动化：借助 PicGo 实现无缝衔接</h2><p>本部分将直接解决用户提出的”不方便”这一核心痛点，通过引入一个强大的自动化工具，并结合文件管理的最佳实践，构建一个高效、优雅的内容创作流程。</p>
<h3 id="3-1-PicGo-简介：连接桌面与云端的桥梁"><a href="#3-1-PicGo-简介：连接桌面与云端的桥梁" class="headerlink" title="3.1 PicGo 简介：连接桌面与云端的桥梁"></a>3.1 PicGo 简介：连接桌面与云端的桥梁</h3><p>PicGo 是一款免费、开源的桌面应用程序，其设计宗旨就是为了极致简化图片的上传流程。它作为一个后台辅助工具，能够：</p>
<ul>
<li><strong>捕获图片</strong>：通过快捷键、剪贴板、拖拽等多种方式捕获需要上传的图片。</li>
<li><strong>自动上传</strong>：将捕获的图片自动上传到预先配置好的云存储服务（如图床）。</li>
<li><strong>生成链接</strong>：上传成功后，自动按照预设格式（如 Markdown、HTML）生成图片的公开访问链接，并将其复制到剪贴板。</li>
</ul>
<p>对于 Hexo 写作者而言，这意味着过去繁琐的手动操作——截图、保存文件、打开 GitHub 仓库、上传文件、复制 URL、手动拼接 Markdown 语法——被彻底简化为一个动作：截图，然后按下一个快捷键。Markdown 格式的图片链接便已在剪贴板中，随时可以粘贴到文章里。这正是解决”不方便”问题的关键所在。</p>
<h3 id="3-2-对象存储中的文件组织最佳实践"><a href="#3-2-对象存储中的文件组织最佳实践" class="headerlink" title="3.2 对象存储中的文件组织最佳实践"></a>3.2 对象存储中的文件组织最佳实践</h3><p>尽管对象存储在技术上是一个扁平的命名空间，但通过在对象键（文件名）中使用斜杠 <code>/</code> 作为分隔符，可以在大多数管理工具中模拟出文件夹的层级结构。例如，一个名为 <code>images/2024/my-post/header.png</code> 的对象，在界面上会显示在 <code>images -&gt; 2024 -&gt; my-post</code> 文件夹下。</p>
<p>利用 PicGo 强大的变量替换功能，我们可以建立一个”一次设定，永久有效”的自动化文件组织体系，无需任何人工干预。</p>
<p><strong>推荐的 PicGo 路径配置</strong>：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">images/</span><span class="template-variable">&#123;year&#125;</span><span class="language-xml">/</span><span class="template-variable">&#123;month&#125;</span><span class="language-xml">/</span><span class="template-variable">&#123;day&#125;</span><span class="language-xml">/</span><span class="template-variable">&#123;timestamp&#125;</span><span class="language-xml">-</span><span class="template-variable">&#123;fileName&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个配置的含义是：</p>
<ul>
<li><code>images/</code>：所有图片都存放在一个名为 images 的根”目录”下，便于统一管理。</li>
<li><code>&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/</code>：根据上传日期自动创建年、月、日的子”目录”，实现按时间顺序的清晰归档，便于日后查找。</li>
<li><code>&#123;timestamp&#125;-</code>：在文件名前添加一个 Unix 时间戳。这是一个至关重要的实践，它能确保每一个上传的文件都拥有一个独一无二的名称，从根本上避免了因文件名重复而导致的意外覆盖问题。</li>
<li><code>&#123;fileName&#125;</code>：保留原始文件名（经过安全处理后），提供了直观的可读性，便于识别图片内容。</li>
</ul>
<p>这种命名结构不仅自动化、保证了唯一性、便于按时间排序，还提供了足够的人类可读信息。更重要的是，它将文件组织的纪律性通过工具强制执行，避免了因人为疏忽导致的长期维护混乱。这不仅仅是便利，更是保障项目长期健康发展的关键策略。</p>
<h2 id="第四部分：端到端实施指南：从零开始实现图片加速"><a href="#第四部分：端到端实施指南：从零开始实现图片加速" class="headerlink" title="第四部分：端到端实施指南：从零开始实现图片加速"></a>第四部分：端到端实施指南：从零开始实现图片加速</h2><p>本部分是报告的核心实践环节，将提供一个详尽的、配有清晰步骤说明的教程，旨在引导初学者完成从账户创建到全功能实现的每一个环节。</p>
<h3 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h3><p>在开始之前，请确保已准备好以下账户和工具：</p>
<ul>
<li>一个 Cloudflare 账户（免费套餐即可开始）。</li>
<li>已安装 Node.js 和 npm（Hexo 环境通常已具备）。</li>
<li>已下载并安装 PicGo 桌面应用程序。</li>
</ul>
<h3 id="4-2-步骤一：配置-Cloudflare-R2-存储基础设施"><a href="#4-2-步骤一：配置-Cloudflare-R2-存储基础设施" class="headerlink" title="4.2 步骤一：配置 Cloudflare R2 存储基础设施"></a>4.2 步骤一：配置 Cloudflare R2 存储基础设施</h3><p>此步骤的目标是创建我们的图片”源站”并获取访问凭证。</p>
<p><strong>创建 R2 存储桶（Bucket）</strong></p>
<ol>
<li>登录 Cloudflare 控制台，在左侧导航栏中找到并进入 R2。</li>
<li>点击 <strong>创建存储桶</strong>。</li>
<li><strong>存储桶名称</strong>：输入一个全局唯一的名称，例如 <code>yourname-hexo-assets</code>。</li>
<li><strong>位置提示</strong>：从下拉菜单中选择一个地理位置。根据我们之前的分析，推荐选择 <strong>亚太地区 (APAC)</strong> 以优化对亚洲用户的访问速度。</li>
<li>点击 <strong>创建存储桶</strong>。</li>
</ol>
<p><strong>生成 S3 兼容的 API 令牌</strong></p>
<ol>
<li>在 R2 的概览页面，点击右上角的 <strong>管理 R2 API 令牌</strong>。</li>
<li>点击 <strong>创建 API 令牌</strong>。</li>
<li><strong>令牌名称</strong>：为令牌起一个描述性的名称，例如 <code>picgo-uploader-token</code>。</li>
<li><strong>权限</strong>：在权限设置中，选择 <strong>对象 → 读取和写入</strong>。这是遵循”最小权限原则”的最佳实践，我们仅授予该令牌上传和读取图片所需的权限，而非完整的管理权限。</li>
<li><strong>指定存储桶（可选）</strong>：为了进一步增强安全性，强烈建议将此令牌的权限范围限定在刚刚创建的特定存储桶上。</li>
<li>点击 <strong>创建 API 令牌</strong>。</li>
<li><strong>关键步骤</strong>：此时，屏幕上会显示 <strong>Access Key ID</strong> 和 <strong>Secret Access Key</strong>。请立即将这两串字符复制并保存到安全的地方（如密码管理器）。<strong>Secret Access Key 只会显示这一次，关闭页面后将无法再次查看</strong>。</li>
</ol>
<p><strong>获取账户 ID 和 S3 端点</strong></p>
<ol>
<li>在 R2 概览页面的右侧，您可以看到您的 <strong>账户 ID</strong>。请复制它。</li>
<li>R2 的 S3 兼容端点（Endpoint）格式为：<code>https://&lt;您的账户ID&gt;.r2.cloudflarestorage.com</code>。请根据您的账户 ID 构建此 URL。</li>
</ol>
<h3 id="4-3-步骤二：配置-PicGo-上传器"><a href="#4-3-步骤二：配置-PicGo-上传器" class="headerlink" title="4.3 步骤二：配置 PicGo 上传器"></a>4.3 步骤二：配置 PicGo 上传器</h3><p>此步骤将配置 PicGo，使其能够将图片自动上传到我们刚刚创建的 R2 存储桶。</p>
<h4 id="⚠️-常见问题排查"><a href="#⚠️-常见问题排查" class="headerlink" title="⚠️ 常见问题排查"></a>⚠️ 常见问题排查</h4><p><strong>问题：搜索插件无结果</strong></p>
<p>如果 PicGo 插件搜索框没有返回任何结果，通常有以下原因：</p>
<ol>
<li><p><strong>网络连接问题</strong>：PicGo 需要访问 npm 仓库 (registry.npmjs.org)。如果网络访问 npm 不稳定，会导致搜索失败。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 npm 使用国内镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p>然后重启 PicGo。</p>
</li>
<li><p><strong>PicGo 版本过旧</strong>：某些旧版本存在已知的插件系统问题。</p>
<p><strong>解决方案</strong>：访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz">PicGo GitHub Releases<i class="fa fa-external-link-alt"></i></span> 下载最新版本。</p>
</li>
<li><p><strong>本地导入成功但选项不出现</strong>：即使通过 git clone 导入插件成功，如果插件未正确加载，Amazon S3 选项仍不会出现。</p>
</li>
</ol>
<h4 id="✅-推荐替代方案：使用-PicList"><a href="#✅-推荐替代方案：使用-PicList" class="headerlink" title="✅ 推荐替代方案：使用 PicList"></a>✅ 推荐替代方案：使用 PicList</h4><p>如果 PicGo 插件安装持续遇到问题，强烈建议使用 PicList —— 一个基于 PicGo 增强优化的版本，内置了 S3 支持，开箱即用。</p>
<p><strong>为什么选择 PicList</strong>：</p>
<ul>
<li>内置 S3 支持无需安装插件</li>
<li>功能更强大（云端文件管理、图片压缩等）</li>
<li>维护更活跃，修复了原版已知问题</li>
<li>用户体验更流畅</li>
</ul>
<p><strong>使用 PicList 配置 R2</strong>：</p>
<ol>
<li><p>下载并安装 PicList：访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0t1aW5nc21pbGUvUGljTGlzdC9yZWxlYXNlcw==">PicList GitHub Releases<i class="fa fa-external-link-alt"></i></span> 下载对应系统的最新版本。</p>
</li>
<li><p>打开 PicList，进入图床设置，直接选择 “Amazon S3”（无需安装任何插件）。</p>
</li>
<li><p>继续使用下面的配置方法。</p>
</li>
</ol>
<h4 id="安装-S3-插件（PicGo-原版）"><a href="#安装-S3-插件（PicGo-原版）" class="headerlink" title="安装 S3 插件（PicGo 原版）"></a>安装 S3 插件（PicGo 原版）</h4><ol>
<li>打开 PicGo 应用程序，进入 <strong>插件设置</strong>。</li>
<li>在搜索框中输入 <code>s3</code>，找到一个通用的 S3 插件（例如 <code>picgo-plugin-s3</code>）并点击安装。</li>
<li>由于 R2 的 S3 兼容性，我们可以直接利用成熟的 S3 插件生态系统，而无需等待专门的 R2 插件。</li>
</ol>
<p><strong>配置 S3 图床</strong></p>
<ol>
<li>安装成功后，进入 <strong>图床设置</strong>，找到并点击 <strong>Amazon S3</strong>。</li>
<li>填写以下配置信息：<ul>
<li><strong>设定 Key Id (Access Key ID)</strong>: 粘贴您在步骤一中保存的 Access Key ID。</li>
<li><strong>设定 Key Secret (Secret Access Key)</strong>: 粘贴您保存的 Secret Access Key。</li>
<li><strong>设定存储空间名 (Bucket)</strong>: 输入您创建的 R2 存储桶的确切名称，例如 <code>yourname-hexo-assets</code>。</li>
<li><strong>指定存储路径 (File Path)</strong>: 输入我们设计的最佳实践路径：<code>images/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;timestamp&#125;-&#123;fileName&#125;</code></li>
<li><strong>设定存储区域 (Region)</strong>: 输入 <code>auto</code>。这是 R2 的特定要求。</li>
<li><strong>设定自定义节点 (Endpoint)</strong>: 输入您在步骤一中构建的 S3 端点 URL，例如 <code>https://&lt;您的账户ID&gt;.r2.cloudflarestorage.com</code>。</li>
<li><strong>设定自定义域名 (Custom URL)</strong>: 暂时留空。我们将在下一步配置自定义域名后回来填写此项。</li>
</ul>
</li>
<li><strong>设为默认图床</strong>：完成配置后，在 PicGo 的主界面或上传区，将默认图床切换为 <strong>Amazon S3</strong>。</li>
</ol>
<h3 id="4-4-步骤三：启用-CDN-全球加速与自定义域名"><a href="#4-4-步骤三：启用-CDN-全球加速与自定义域名" class="headerlink" title="4.4 步骤三：启用 CDN 全球加速与自定义域名"></a>4.4 步骤三：启用 CDN 全球加速与自定义域名</h3><p>此步骤的目标是为我们的图片资源启用一个专业的、全球加速的访问地址。</p>
<p><strong>为何使用自定义域名</strong></p>
<ul>
<li><strong>专业性</strong>：使用 <code>media.yourdomain.com</code> 这样的子域名比使用 R2 默认的 <code>r2.dev</code> 域名看起来更专业。</li>
<li><strong>可移植性</strong>：您的所有博文都将引用这个自定义域名。未来如果您决定更换存储服务商，只需更新该域名的 DNS 解析即可，无需修改任何历史文章中的图片链接，从而避免了供应商锁定。</li>
<li><strong>性能与控制</strong>：只有通过自定义域名，才能充分利用 Cloudflare 强大的 CDN 缓存、安全规则和其他增值功能。</li>
</ul>
<p><strong>连接自定义域名到 R2 存储桶</strong></p>
<h4 id="⚠️-常见问题：域名在不同账号下"><a href="#⚠️-常见问题：域名在不同账号下" class="headerlink" title="⚠️ 常见问题：域名在不同账号下"></a>⚠️ 常见问题：域名在不同账号下</h4><p><strong>问题描述</strong>：Cloudflare R2 的”连接域”功能只能连接到同一个 Cloudflare 账号下的域名。如果您的 R2 存储桶和域名在不同的账号中，您将无法在 R2 设置页面看到您的域名。</p>
<p><strong>解决方案二选一</strong>：</p>
<h5 id="方案一：将域名迁移到-R2-所在账号（推荐）"><a href="#方案一：将域名迁移到-R2-所在账号（推荐）" class="headerlink" title="方案一：将域名迁移到 R2 所在账号（推荐）"></a>方案一：将域名迁移到 R2 所在账号（推荐）</h5><p>这是最规范、最一劳永逸的方案：</p>
<ol>
<li><strong>登录有域名的账号</strong>，找到要迁移的域名（如 <code>yourdomain.com</code>）</li>
<li><strong>删除域名</strong>：在域名设置底部选择”从 Cloudflare 中删除站点”（注意：这会删除所有 DNS 记录，请确保域名未在使用）</li>
<li><strong>登录 R2 所在账号</strong>，点击”添加站点”</li>
<li><strong>重新添加域名</strong>，按照提示完成添加过程（选择免费计划）</li>
<li><strong>返回 R2 设置</strong>，现在您应该能看到并选择这个域名了</li>
</ol>
<h5 id="方案二：手动跨账号绑定-CNAME"><a href="#方案二：手动跨账号绑定-CNAME" class="headerlink" title="方案二：手动跨账号绑定 CNAME"></a>方案二：手动跨账号绑定 CNAME</h5><p>如果无法迁移域名，可以手动配置：</p>
<ol>
<li><p><strong>获取 R2 公共 URL</strong>：</p>
<ul>
<li>进入 R2 存储桶 → 设置 → 公共访问</li>
<li>启用”允许访问”，获得形如 <code>[bucket].pub-[id].r2.dev</code> 的 URL</li>
</ul>
</li>
<li><p><strong>在域名账号配置 DNS</strong>：</p>
<ul>
<li>登录有域名的账号</li>
<li>进入 DNS 管理，添加 CNAME 记录：<ul>
<li><strong>类型</strong>：CNAME</li>
<li><strong>名称</strong>：media（或其他子域名）</li>
<li><strong>目标</strong>：粘贴第一步获得的 r2.dev URL</li>
<li><strong>代理状态</strong>：必须设置为”已代理”（橙色云朵图标）</li>
</ul>
</li>
<li>保存并等待 DNS 生效</li>
</ul>
</li>
<li><p><strong>验证配置</strong>：</p>
<ul>
<li>访问 <code>https://media.yourdomain.com</code> 应该能正常显示</li>
</ul>
</li>
</ol>
<p><strong>标准流程（域名在同一个账号下）</strong>：</p>
<ol>
<li>返回 Cloudflare 控制台的 R2 存储桶页面，点击进入您创建的存储桶。</li>
<li>选择 <strong>设置</strong> 选项卡。</li>
<li>在 <strong>公共访问 → 自定义域</strong> 部分，点击 <strong>连接域</strong>。</li>
<li>输入您希望使用的子域名，例如 <code>media.yourblog.com</code>。</li>
<li>Cloudflare 会自动为您创建一个 CNAME 类型的 DNS 记录，指向 R2 服务。</li>
<li>确认并创建。</li>
<li>等待几分钟，直到域名的状态变为 <strong>有效</strong>。</li>
</ol>
<p><strong>更新 PicGo 配置</strong></p>
<ol>
<li>回到 PicGo 的 S3 图床设置。</li>
<li>在 <strong>设定自定义域名 (Custom URL)</strong> 字段中，填入您刚刚配置的完整域名，务必包含 <code>https://</code>，例如 <code>https://media.yourblog.com</code>。</li>
<li>保存设置。</li>
</ol>
<p>现在，PicGo 上传图片后，复制到剪贴板的将是这个专业的、全球加速的 URL。</p>
<h3 id="4-5-步骤四：精调性能：配置-CDN-缓存规则"><a href="#4-5-步骤四：精调性能：配置-CDN-缓存规则" class="headerlink" title="4.5 步骤四：精调性能：配置 CDN 缓存规则"></a>4.5 步骤四：精调性能：配置 CDN 缓存规则</h3><p>此步骤将指示 Cloudflare CDN 尽可能长时间地缓存您的图片，以实现最佳加载速度并最大限度地减少对 R2 源站的读取操作（从而节省免费额度内的 B 类操作次数）。</p>
<p><strong>创建缓存规则</strong></p>
<ol>
<li>在 Cloudflare 控制台中，选择您的主域名，然后进入 <strong>缓存 → 缓存规则</strong>。</li>
<li>点击 <strong>创建规则</strong>。</li>
<li><strong>规则名称</strong>：输入一个描述性的名称，例如 <code>Cache R2 Images Forever</code>。</li>
<li><strong>当传入请求匹配时… (表达式)</strong>:<ul>
<li>字段: <code>主机名</code></li>
<li>运算符: <code>等于</code></li>
<li>值: <code>media.yourblog.com</code> (您在步骤三中配置的域名)</li>
</ul>
</li>
<li><strong>然后… (缓存资格)</strong>: 选择 <code>符合缓存条件</code>。</li>
<li><strong>然后… (边缘 TTL)</strong>: 选择 <code>边缘缓存 TTL</code>，并设置一个较长的缓存时间，例如 <code>一个月</code> 或 <code>一年</code>。</li>
<li>由于我们的文件名通过时间戳保证了唯一性，每个 URL 都指向一个不可变的内容，因此可以安全地设置长缓存时间。</li>
<li>点击 <strong>部署</strong>。</li>
</ol>
<h3 id="4-6-体验全新的自动化工作流"><a href="#4-6-体验全新的自动化工作流" class="headerlink" title="4.6 体验全新的自动化工作流"></a>4.6 体验全新的自动化工作流</h3><p>至此，整个专业级的图片加速与自动化工作流已全部配置完毕。现在，您的写作流程将变得无比顺畅：</p>
<ol>
<li>使用您喜欢的工具截取屏幕截图，或复制一个本地图片文件。</li>
<li>按下您在 PicGo 中设置的上传快捷键（例如 <code>Cmd+Shift+P</code>）。</li>
<li>片刻之后，系统会弹出上传成功的通知。</li>
<li>在您的 Hexo Markdown 文件中，直接粘贴。</li>
</ol>
<p>一个格式完美的 Markdown 图片链接，如 <code>![图片描述](https://media.yourblog.com/images/2024/08/23/1661234567-header.png)</code>，就已经准备就绪。</p>
<p>从繁琐的手动操作到一键式的自动化上传，您已成功解决了”不方便”的核心问题，并为您的网站赋予了世界级的性能。</p>
<h2 id="结论：为您的数字资产奠定一个面向未来的坚实基础"><a href="#结论：为您的数字资产奠定一个面向未来的坚实基础" class="headerlink" title="结论：为您的数字资产奠定一个面向未来的坚实基础"></a>结论：为您的数字资产奠定一个面向未来的坚实基础</h2><p>通过遵循本指南的步骤，您已经成功地为您的 Hexo 博客和文档网站构建了一个专业、高效且极具成本效益的媒体资产管理系统。我们来回顾一下所达成的核心目标：</p>
<ul>
<li><strong>卓越性能</strong>：通过将图片资源迁移到专用的对象存储，并利用 Cloudflare 的全球 CDN 网络进行分发，您的网站访问者无论身在何处，都能享受到飞快的图片加载速度。</li>
<li><strong>极致便利</strong>：借助 PicGo 的自动化能力，图片上传和链接生成过程被简化为单一快捷键操作，极大地提升了内容创作的效率和流畅度。</li>
<li><strong>现代架构</strong>：您采用的”对象存储 + CDN”是当前业界领先的 Web 资产交付架构，它不仅解决了眼前的问题，也为未来的功能扩展（如视频、音频或其他静态文件托管）提供了坚实的基础。</li>
<li><strong>成本可控</strong>：得益于 Cloudflare R2 慷慨的免费额度，特别是革命性的”零出口流量费”政策，您的个人项目可以在几乎零成本的情况下运行，并且即使未来流量大幅增长，也无需担心不可预测的带宽费用。</li>
</ul>
<p>通过投入少量时间进行一次性配置，您不仅解决了一个具体的技术问题，更是为您的个人数字品牌进行了一次重要的基础设施投资。这个稳固、可扩展且面向未来的架构，将确保您的内容能够以最佳状态、最快速度触达全球读者，为您的创作之旅提供持久而强大的技术支持。</p>
]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp; LLM</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>gemini</tag>
        <tag>blog</tag>
        <tag>javascript</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>The Evolution of My GitHub Profile</title>
    <url>/posts/17888/</url>
    <content><![CDATA[<blockquote>
<p>摘要：记录了一次有趣的”人机协作”经历——和Gemini一起从零开始，打造了一个让我非常满意的Github Profile。</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="🎯-先看效果，再聊过程"><a href="#🎯-先看效果，再聊过程" class="headerlink" title="🎯 先看效果，再聊过程"></a>🎯 先看效果，再聊过程</h2><p>我的GitHub Profile现在长这样：</p>
<ul>
<li><strong>个人简介</strong>：简洁的自我介绍）</li>
<li><strong>技术栈展示</strong>：用图标展示我会的编程语言（虽然有些可能已经忘得差不多了😅）</li>
<li><strong>数学卡片</strong>：高斯绝妙定理–数学之美！</li>
<li><strong>动态博客列表</strong>：自动更新我最新写的文章</li>
<li><strong>贪吃蛇贡献图</strong>：把GitHub的贡献日历变成动画，单纯好玩</li>
</ul>
<p>一开始我就是想要个好看的Profile</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog/year-month/name" alt="最终效果预览"></p>
<h2 id="🛠️-技术实现：从简单到复杂"><a href="#🛠️-技术实现：从简单到复杂" class="headerlink" title="🛠️ 技术实现：从简单到复杂"></a>🛠️ 技术实现：从简单到复杂</h2><h3 id="1-基础部分：Markdown-HTML"><a href="#1-基础部分：Markdown-HTML" class="headerlink" title="1. 基础部分：Markdown + HTML"></a>1. 基础部分：Markdown + HTML</h3><p>GitHub Profile本质上就是一个<code>README.md</code>文件。Markdown -&gt; HTML 懂了吧。</p>
<blockquote>
<p>💡 <strong>踩雷记录</strong>：GitHub Profile的README.md文件有特殊的渲染规则，支持HTML但不支持所有CSS属性，比如坑爹的超链接！</p>
</blockquote>
<h4 id="个人介绍：简洁清爽"><a href="#个人介绍：简洁清爽" class="headerlink" title="个人介绍：简洁清爽"></a>个人介绍：简洁清爽</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">### 👨‍💻 About Me</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: left; display: inline-block;&quot;</span>&gt;</span></span><br><span class="line"> 🎓 毕业于 **清华大学 (THU)**</span><br><span class="line"> 🌱 目前就读于 **中国科学院大学 (UCAS)**</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="技术栈：用现成的"><a href="#技术栈：用现成的" class="headerlink" title="技术栈：用现成的"></a>技术栈：用现成的</h4><p>用<span class="exturl" data-url="aHR0cHM6Ly9za2lsbGljb25zLmRldi8=">skillicons.dev<i class="fa fa-external-link-alt"></i></span>，一行代码即可。</p>
<blockquote>
<p>🎯 <strong>为什么选择这个服务？</strong> 完全免费，部署简单，”懒人”福音</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://skillicons.dev&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://skillicons.dev/icons?i=python,cpp,java,js,html,css,latex,vscode,git&amp;perline=9&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="特色卡片：数学之美"><a href="#特色卡片：数学之美" class="headerlink" title="特色卡片：数学之美"></a>特色卡片：数学之美</h4><p>我最喜欢的数学家——高斯和他都觉得妙的——高斯绝妙定理：</p>
<blockquote>
<p>🧮 <strong>高斯绝妙定理</strong> 这个定理告诉say： 曲面的高斯曲率是内蕴几何量，不依赖于曲面在空间中的嵌入方式。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #d0d7de; border-radius: 6px; padding: 16px; margin: 16px 0;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; align-items: center; gap: 16px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://media.makomako.dpdns.org/avatar/Gauss.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;120&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 6px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Theorema Egregium<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>高斯绝妙定理：曲面的高斯曲率K是内蕴几何量<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://en.wikipedia.org/wiki/Theorema_Egregium&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;https://latex.codecogs.com/svg.latex?\color&#123;white&#125;\Large<span class="symbol">&amp;space;</span>K=\kappa_1\kappa_2&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(prefers-color-scheme: light)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;https://latex.codecogs.com/svg.latex?\color&#123;black&#125;\Large<span class="symbol">&amp;space;</span>K=\kappa_1\kappa_2&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://latex.codecogs.com/svg.latex?\color&#123;black&#125;\Large<span class="symbol">&amp;space;</span>K=\kappa_1\kappa_2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-自动化：Profile”活”了"><a href="#2-自动化：Profile”活”了" class="headerlink" title="2. 自动化：Profile”活”了"></a>2. 自动化：Profile”活”了</h3><p>这部分是让Profile真正”活”起来的关键。通过GitHub Actions，实现自动更新，让Profile不再是静态的展示页面。</p>
<h4 id="自动更新博客列表"><a href="#自动更新博客列表" class="headerlink" title="自动更新博客列表"></a>自动更新博客列表</h4><p>用<code>gautamkrishnar/blog-post-workflow</code>这个Action，配置简单，每次发布新博客，Profile就会自动更新，无需手动维护：</p>
<blockquote>
<p>🔄 <strong>自动化原理</strong>：这个Action会定期抓取博客RSS Feed，然后自动更新README.md文件中的博客列表。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Latest</span> <span class="string">blog</span> <span class="string">post</span> <span class="string">workflow</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 * * * *&#x27;</span>  <span class="comment"># 每小时运行一次</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update-readme-with-blog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Update</span> <span class="string">this</span> <span class="string">repo&#x27;s</span> <span class="string">README</span> <span class="string">with</span> <span class="string">latest</span> <span class="string">blog</span> <span class="string">posts</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">gautamkrishnar/blog-post-workflow@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">disable_cache:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">feed_list:</span> <span class="string">&quot;https://zhu-jl18.github.io/atom.xml&quot;</span></span><br><span class="line">          <span class="attr">max_post_count:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">template:</span> <span class="string">&#x27;&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;\(url&quot; style=&quot;text-decoration: none; color: #20B2AA;&quot;&gt;\)title&lt;/a&gt;&lt;/p&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在README中设置占位符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">### 📝 Recent Blog Posts</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #d0d7de; border-radius: 6px; padding: 16px;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- BLOG-POST-LIST:START --&gt;</span><span class="comment">&lt;!-- BLOG-POST-LIST:END --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="贪吃蛇贡献图"><a href="#贪吃蛇贡献图" class="headerlink" title="贪吃蛇贡献图"></a>贪吃蛇贡献图</h4><p>用<code>Platane/snk</code>这个Action，自动生成动画版的贡献图。这个功能纯粹是为了好玩：</p>
<blockquote>
<p>🐍 <strong>“贪吃蛇”？！</strong> 因为这个动画看起来就像一条蛇在吃贡献点，从年初吃到年末。虽然没什么实际用途，因为我基本不贡献。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">generate</span> <span class="string">animation</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 0 * * *&quot;</span>  <span class="comment"># 每天运行一次</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">generate:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">timeout-minutes:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">Platane/snk@v3</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">snake-gif</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_user_name:</span> <span class="string">zhu-jl18</span></span><br><span class="line">          <span class="attr">svg_out_path:</span> <span class="string">dist/github-snake.svg</span></span><br><span class="line">          <span class="attr">snake_color:</span> <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">crazy-max/ghaction-github-pages@v2.1.3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">target_branch:</span> <span class="string">output</span></span><br><span class="line">          <span class="attr">build_dir:</span> <span class="string">dist</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后在README中引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;https://raw.githubusercontent.com/zhu-jl18/zhu-jl18/output/github-snake-dark.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(prefers-color-scheme: light)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;https://raw.githubusercontent.com/zhu-jl18/zhu-jl18/output/github-snake.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;github snake animation&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/zhu-jl18/zhu-jl18/output/github-snake.svg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="🤖-人机协作实录"><a href="#🤖-人机协作实录" class="headerlink" title="🤖 人机协作实录"></a>🤖 人机协作实录</h2><p>此部分记录了与Gemini共同实现Profile的过程。我负责设计思路与整体规划，Gemini负责具体代码实现。</p>
<blockquote>
<p>🤖 <strong>协作原则</strong>：大模型不是万能的，它虽然懂得很多，但是你得让他明白你到底要他干什么~</p>
</blockquote>
<h3 id="协作过程"><a href="#协作过程" class="headerlink" title="协作过程"></a>协作过程</h3><p><strong>我</strong>：我想在GitHub Profile上展示我的博客列表，有什么好办法吗？</p>
<p><strong>Gemini</strong>：可以用<code>blog-post-workflow</code>这个Action，配置很简单…</p>
<p><strong>结果</strong>：基础功能实现了，但样式很丑。典型的”能用就行”状态。</p>
<h3 id="第二轮：样式优化"><a href="#第二轮：样式优化" class="headerlink" title="第二轮：样式优化"></a>第二轮：样式优化</h3><p><strong>我</strong>：这个列表样式不好看，我想要卡片式布局，并且居中显示。</p>
<p><strong>Gemini</strong>：可以用复杂的HTML+CSS来实现…</p>
<p><strong>结果</strong>：GitHub不支持复杂的CSS样式，居中效果失效了。这就是典型的”过度设计”问题。</p>
<h3 id="第三轮：回归本质"><a href="#第三轮：回归本质" class="headerlink" title="第三轮：回归本质"></a>第三轮：回归本质</h3><p><strong>我</strong>：GitHub不支持这些复杂样式，还是都在左边。我不要日期了，字体大小也改不了，就让它简单的居中就行。</p>
<p><strong>Gemini</strong>：那就用最简单的<code>&lt;p align=&quot;center&quot;&gt;</code>标签吧。</p>
<p><strong>结果</strong>：完美！有时候最简单的方案就是最好的方案。这让我想起了KISS原则（Keep It Simple, Stupid）。</p>
<h2 id="💡-协作心得"><a href="#💡-协作心得" class="headerlink" title="💡 协作心得"></a>💡 协作心得</h2><p>与AI协作编程！！！：</p>
<ol>
<li><strong>明确目标</strong>：想清楚你要什么，不要模棱两可。AI不是读心术，你得说清楚。</li>
<li><strong>小步快跑</strong>：尝试一个方案，立即测试，然后带着结果进行下一轮沟通。不要一次性要求太多。</li>
<li><strong>提供精确反馈</strong>：不要说”不行”，要说”哪里不行”、”为什么不行”。AI需要具体的错误信息。</li>
<li><strong>回归本质</strong>：当复杂方案失效时，往往最简单的方案最有效。这大概就是所谓的”大道至简”吧。</li>
</ol>
<p>总的来说， AI极其吃数据，你喂给他是好东西他就也会输出好东西。</p>
<h2 id="🎉-总结"><a href="#🎉-总结" class="headerlink" title="🎉 总结"></a>🎉 总结</h2><p>Gemini还不错，最后效果超出我预料地好看。</p>
<p><strong>这是我大模型使用的初期探索，后来我会了很多优化技巧，早期的这些尝试也是很有意思的。</strong></p>
<hr>
<p><strong>Ref:</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhdXRhbWtyaXNobmFyL2Jsb2ctcG9zdC13b3JrZmxvdw==">blog-post-workflow<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9za2lsbGljb25zLmRldi8=">skillicons.dev<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BsYXRhbmUvc25r">snk<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp; LLM</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>git</tag>
        <tag>gemini</tag>
        <tag>blog</tag>
        <tag>javascript</tag>
        <tag>css</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>网络代理全解析：从入门到精通</title>
    <url>/posts/3c844e5f/</url>
    <content><![CDATA[<blockquote>
<p>本文记录了 mako 与其AI助手 fish 的一次深度合作。我们共同发现问题、反复推演，并最终设计出一套全新的Git工作流，旨在为每一位同时是“开发者”和“创作者”的博主，带来极致的发布体验。</p>
</blockquote>
<span id="more"></span>

<hr>
<p>你好，各位在数字世界中冲浪的探索者！我是fish，今天我们将共同探讨一个既熟悉又陌生的话题——网络代理。</p>
<h2 id="一、代理（Proxy）：你的网络信使"><a href="#一、代理（Proxy）：你的网络信使" class="headerlink" title="一、代理（Proxy）：你的网络信使"></a>一、代理（Proxy）：你的网络信使</h2><p>代理服务器是你和目标网站之间的中介。它的基础工作流程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[你] ---&gt; [代理服务器] ---&gt; [目标网站]</span><br></pre></td></tr></table></figure>

<p>这个“信使”的核心作用是：</p>
<ol>
<li><strong>隐藏身份</strong>：隐藏你的真实IP地址。</li>
<li><strong>访问限制内容</strong>：通过位于不同地区的“信使”来访问那些对你所在地区屏蔽的内容。</li>
<li><strong>加速访问与安全过滤</strong>：缓存内容，过滤风险。</li>
</ol>
<h2 id="二、系统代理：操作系统的“中央信使派遣中心”"><a href="#二、系统代理：操作系统的“中央信使派遣中心”" class="headerlink" title="二、系统代理：操作系统的“中央信使派遣中心”"></a>二、系统代理：操作系统的“中央信使派遣中心”</h2><p>“系统代理”是操作系统（如Windows、macOS）提供的一个全局设置。当你设置了它，就等于告诉操作系统：“从现在开始，所有‘听话’的程序，默认都从我指定的这个代理出口走。”</p>
<p>最常见的系统代理模式是：</p>
<ol>
<li><strong>手动设置 (Manual Proxy)</strong>：手动指定信使的地址和端口（例如 <code>127.0.0.1:7890</code>）。</li>
<li><strong>PAC脚本 (Proxy Auto-Config)</strong>：提供一个URL，内容是一个JS脚本。这本脚本像一本《信使选择指南》，能根据你访问的网址，决定是走代理还是直连。</li>
</ol>
<h2 id="三、VPN-vs-代理：装甲车与信使的区别"><a href="#三、VPN-vs-代理：装甲车与信使的区别" class="headerlink" title="三、VPN vs 代理：装甲车与信使的区别"></a>三、VPN vs 代理：装甲车与信使的区别</h2><ul>
<li><strong>代理 (Proxy)</strong>：通常工作在<strong>应用层</strong>，更像一个<strong>信使</strong>，主要负责转发特定类型的请求（如HTTP）。</li>
<li><strong>VPN (虚拟专用网络)</strong>：工作在更底层的<strong>网络层</strong>，像一辆<strong>加密装甲车</strong>，把你电脑所有的网络数据都打包塞入隧道，发往远方。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">代理: [你的浏览器] --http--&gt; [代理服务器] --http--&gt; [目标网站]</span><br><span class="line"></span><br><span class="line">VPN:  [你的整台电脑] --加密隧道--&gt; [VPN服务器] ---&gt; [任何目标网站]</span><br></pre></td></tr></table></figure>

<h2 id="四、核心对决：系统代理-vs-自定义代理"><a href="#四、核心对决：系统代理-vs-自定义代理" class="headerlink" title="四、核心对决：系统代理 vs 自定义代理"></a>四、核心对决：系统代理 vs 自定义代理</h2><ul>
<li><strong>使用系统代理的软件 (The Good Citizen)</strong>：如Chrome, Edge。它们信任并遵守操作系统的全局代理设置。</li>
<li><strong>使用自定义代理的软件 (The Rebel)</strong>：如Firefox, Telegram, 命令行工具。它们无视全局设置，需要你在软件内部为它指定专属的代理。</li>
</ul>
<h2 id="番外篇-I：Steamcommunity-302-这类工具的奥秘"><a href="#番外篇-I：Steamcommunity-302-这类工具的奥秘" class="headerlink" title="番外篇 I：Steamcommunity 302 这类工具的奥秘"></a>番外篇 I：Steamcommunity 302 这类工具的奥秘</h2><p>这类工具并非VPN，而是一种本地HTTP代理，它通过“302重定向”来巧妙地解决DNS污染等问题。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 你的电脑: &quot;我要访问 github.com&quot;</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">2. hosts文件: &quot;github.com -&gt; 127.0.0.1 (302工具自己)&quot;</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">3. 302工具 (在本地): &quot;收到！别去那，给你个新地址 1.2.3.4&quot; (返回302重定向)</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">4. 你的电脑: &quot;好的！那我访问新地址 1.2.3.4&quot; --&gt; [真正的GitHub服务器 1.2.3.4]</span><br></pre></td></tr></table></figure>

<p>由于它只懂HTTP协议，所以无法处理SSH (<code>git@github.com:...</code>) 的请求，这解释了为何用它时只能走HTTPS链接。</p>
<h2 id="实战问答-Q-A-：从入门到精通"><a href="#实战问答-Q-A-：从入门到精通" class="headerlink" title="实战问答 (Q&amp;A)：从入门到精通"></a>实战问答 (Q&amp;A)：从入门到精通</h2><hr>
<p><strong>Q1: 很多命令行下载失败的“玄学bug”，根源是代理问题？如何一劳永逸配置，又如何临时取消？</strong></p>
<p>A: 完全正确！解决方案是：<strong>设置通用规则，并为特殊情况留出例外。</strong></p>
<ol>
<li><strong>“一劳永逸”</strong>：将 <code>export http_proxy=&quot;...&quot;</code> 这样的命令写入你终端的配置文件中（如 <code>~/.bashrc</code>）。</li>
<li><strong>“处理例外”</strong>：临时取消可使用 <code>unset http_proxy</code>；更优雅的是用 <code>export no_proxy=&quot;*.aliyun.com,*.163.com&quot;</code> 设置白名单。</li>
</ol>
<hr>
<p><strong>Q2: <code>mihomo</code> (Clash) 里的“系统代理”、“规则&#x2F;全局&#x2F;直连模式”和“虚拟网卡”都是做什么的？</strong></p>
<p>A: 这些是高级代理工具的灵魂。</p>
<ul>
<li><strong>系统代理开关</strong>：是“交通广播员”，向守规矩的应用广播代理地址。</li>
<li><strong>连接模式</strong>：是“总指挥”的策略。<code>直连</code>是全员放假；<code>全局</code>是所有人都必须走一个门；<code>规则</code>是最智能的，按手册精细调度所有流量。</li>
<li><strong>虚拟网卡 (TUN Mode)</strong>：是“终极武器”。它在网络层创建一个虚拟网卡，强制接管<strong>所有</strong>程序的流量（包括不听话的程序和WSL2），实现真正的“全局代理”。</li>
</ul>
<hr>
<p><strong>Q3: WSL的网络怎么处理？Clash里的“代理组”、“规则”、“覆写”和“嗅探”这些高级功能又该如何理解？</strong></p>
<p>A: 这些是精通此道的最后几块拼图。</p>
<ul>
<li><strong>WSL的网络</strong>：它是一个独立的“平行世界”，无视主机的代理设置。<strong>开启TUN模式</strong>是让它接入代理的最优解。</li>
<li><strong>“规则”与“代理组”</strong>：“规则”是<strong>交通法规</strong>，负责引流；“代理组”是<strong>环岛</strong>，负责疏导。规则决策，代理组执行。</li>
<li><strong>代理组的日常使用</strong>：一个好的配置，大部分代理组都是<strong>自动化</strong>的（比速度、自动切换）。你只需偶尔在顶层的<code>select</code>（手动选择）组里切换策略即可。代理组还可以<strong>嵌套</strong>，实现更灵活的控制。</li>
<li><strong>“订阅”与“覆写”</strong>：“订阅”是服务商的“预制菜单”；“覆写”是你自己的、优先级最高的“我的菜单”，用以实现个性化配置。</li>
<li><strong>终极规则与高级功能</strong>：<code>FINAL</code>规则负责处理所有未匹配的流量；<code>PROCESS-NAME</code>规则可以控制某个exe程序的所有流量；<code>DNS覆写</code>和<code>嗅探</code>是处理疑难杂症的终极手段。</li>
</ul>
<hr>
<p><strong>Q4: Cloudflare的例子算双重代理吗？以及，同时开“虚拟网卡”和“系统代理”会怎样？</strong></p>
<p>A: 这个思考完全抓住了代理模型的精髓！</p>
<ul>
<li><p><strong>代理的双重身份</strong><br>在那个场景中，Cloudflare脚本确实具有双重性：对<strong>你</strong>而言，它是<strong>反向代理</strong>；对<strong>ChatGPT</strong>而言，它扮演了<strong>正向代理</strong>的角色。这完美地诠释了代理架构中的信息不对称之美。</p>
</li>
<li><p><strong>“虚拟网卡” vs “系统代理”的终极对决</strong><br><strong>“虚拟网卡”完胜</strong>。因为它在更底层的网络层工作，会先于应用层的“系统代理”捕获流量。当TUN开启时，系统代理开关基本可以忽略。</p>
</li>
</ul>
<h2 id="番外篇-II：从正向代理到反向代理"><a href="#番外篇-II：从正向代理到反向代理" class="headerlink" title="番外篇 II：从正向代理到反向代理"></a>番外篇 II：从正向代理到反向代理</h2><p>我们一直在讨论的，都属于<strong>正向代理 (Forward Proxy)</strong>。它为<strong>客户端</strong>服务，隐藏客户端身份。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">           [你的电脑]             [你的订阅服务器]             [YouTube服务器]</span><br><span class="line">(你) --&gt; (mihomo/Clash) --&gt; (如日本节点) --&gt; (Google服务器)</span><br></pre></td></tr></table></figure>

<p>而<strong>反向代理 (Reverse Proxy)</strong>，则为<strong>服务端</strong>服务，隐藏服务端身份。mako设想的Cloudflare脚本，就是一个完美的反向代理实例。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">           [你的电脑]         [Cloudflare/你的服务器]        [真正的ChatGPT服务器]</span><br><span class="line">(你) &lt;------&gt; (反向代理脚本) &lt;------&gt; (OpenAI服务器集群)</span><br></pre></td></tr></table></figure>

<p><strong>一张表看懂核心区别：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">正向代理 (Forward Proxy)</th>
<th align="left">反向代理 (Reverse Proxy)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>服务对象</strong></td>
<td align="left"><strong>客户端 (你)</strong></td>
<td align="left"><strong>服务端 (网站)</strong></td>
</tr>
<tr>
<td align="left"><strong>隐藏对象</strong></td>
<td align="left">隐藏真实的<strong>客户端</strong></td>
<td align="left">隐藏真实的<strong>服务端</strong></td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left">你雇的“海外代购”</td>
<td align="left">淘宝的“官方客服”</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">科学上网、内网穿透</td>
<td align="left">网站负载均衡、安全防护(WAF)、API网关</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，mako，你已经是一位合格的网络代理架构师了！从区分最基础的系统代理，到理解复杂的代理工具链，再到构思自己的反向代理应用，你已经建立起了完整的知识体系。</p>
<p>希望这篇由我们共同完成的指南，能帮助更多在网络世界探索的人。</p>
]]></content>
      <categories>
        <category>AI &amp; LLM</category>
        <category>技术记录与分享</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>git</tag>
        <tag>javascript</tag>
        <tag>proxy</tag>
        <tag>ai</tag>
        <tag>workflow</tag>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>From jsDelivr To Cloudflare R2</title>
    <url>/posts/5705467b/</url>
    <content><![CDATA[<blockquote>
<p> 图床迁移记录</p>
</blockquote>
<span id="more"></span>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在前一篇文章《Hexo博客构建专业级图片加速与自动化工作流》中，详细介绍了如何从零开始搭建基于 Cloudflare R2 的现代化图片管理系统。然而，对于像我这样的现有用户来说，还有一个关键问题没有解决：<strong>如何将现有的图片资源从 jsDelivr + GitHub CDN 平滑迁移到新的 R2 系统？</strong></p>
<p>本文将作为一个实战指南，详细记录我从 zhu-jl18&#x2F;cdn4blog 仓库迁移到 Cloudflare R2 的完整过程，分享遇到的挑战、解决方案以及最佳实践。</p>
<h2 id="迁移前的准备工作"><a href="#迁移前的准备工作" class="headerlink" title="迁移前的准备工作"></a>迁移前的准备工作</h2><h3 id="1-资源盘点"><a href="#1-资源盘点" class="headerlink" title="1. 资源盘点"></a>1. 资源盘点</h3><p>在开始迁移前，首先需要全面梳理现有的图片资源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索项目中所有使用旧 CDN 地址的文件</span></span><br><span class="line">grep -r <span class="string">&quot;cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog&quot;</span> <span class="built_in">source</span>/ --include=<span class="string">&quot;*.md&quot;</span> --include=<span class="string">&quot;*.yml&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过搜索发现，我的博客中有：</p>
<ul>
<li><strong>12 篇文章</strong>使用了旧 CDN 地址</li>
<li><strong>配置文件</strong>中的 logo 链接</li>
<li><strong>文章模板</strong>中的头像地址</li>
<li><strong>总计约 20 个图片</strong>需要迁移</li>
</ul>
<h3 id="2-制定迁移计划"><a href="#2-制定迁移计划" class="headerlink" title="2. 制定迁移计划"></a>2. 制定迁移计划</h3><p>基于资源盘点结果，制定了以下迁移策略：</p>
<ol>
<li><strong>保持 URL 结构兼容性</strong>：为了最小化对历史文章的影响，决定在 R2 中保持原有的图片路径结构</li>
<li><strong>使用自定义域名</strong>：设置 <code>media.zhu-jl18.github.io</code> 作为图片域名，确保未来可移植性</li>
<li><strong>分阶段迁移</strong>：先迁移少量测试，确认无误后再批量处理</li>
</ol>
<h2 id="详细迁移步骤"><a href="#详细迁移步骤" class="headerlink" title="详细迁移步骤"></a>详细迁移步骤</h2><h3 id="第一步：R2-存储桶配置"><a href="#第一步：R2-存储桶配置" class="headerlink" title="第一步：R2 存储桶配置"></a>第一步：R2 存储桶配置</h3><p>按照前文教程创建好 R2 存储桶后，关键的一步是设计合理的存储路径：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">建议的路径结构：</span><br><span class="line">├── avatar<span class="symbol">/</span>           <span class="comment"># 头像类图片</span></span><br><span class="line">├── logo<span class="symbol">/</span>             <span class="comment"># logo 文件</span></span><br><span class="line">├── <span class="number">2021</span><span class="symbol">/</span>             <span class="comment"># 按年月归档</span></span><br><span class="line">│   ├── <span class="number">3</span><span class="symbol">/</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── <span class="number">2025</span><span class="symbol">/</span></span><br><span class="line">│   ├── <span class="number">8</span><span class="symbol">/</span></span><br><span class="line">│   └── ...</span><br><span class="line">└── blog-images<span class="symbol">/</span>      <span class="comment"># 通用博客图片</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步：批量上传图片资源"><a href="#第二步：批量上传图片资源" class="headerlink" title="第二步：批量上传图片资源"></a>第二步：批量上传图片资源</h3><p>这里遇到了第一个挑战：如何高效地将 GitHub 仓库的图片批量上传到 R2？</p>
<h4 id="方案一：使用-AWS-CLI-S3-Sync"><a href="#方案一：使用-AWS-CLI-S3-Sync" class="headerlink" title="方案一：使用 AWS CLI + S3 Sync"></a>方案一：使用 AWS CLI + S3 Sync</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 AWS CLI</span></span><br><span class="line">pip install awscli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 AWS CLI 指向 R2</span></span><br><span class="line">aws configure</span><br><span class="line"><span class="comment"># AWS Access Key ID: [你的 R2 Access Key]</span></span><br><span class="line"><span class="comment"># AWS Secret Access Key: [你的 R2 Secret Key]</span></span><br><span class="line"><span class="comment"># Default region name: auto</span></span><br><span class="line"><span class="comment"># Default output format: json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录并克隆 CDN 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zhu-jl18/cdn4blog.git temp-cdn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 s3 sync 批量同步</span></span><br><span class="line">aws s3 <span class="built_in">sync</span> temp-cdn/ s3://your-hexo-assets --endpoint https://&lt;account-id&gt;.r2.cloudflarestorage.com</span><br></pre></td></tr></table></figure>

<h4 id="方案二：Python-脚本（更可控）"><a href="#方案二：Python-脚本（更可控）" class="headerlink" title="方案二：Python 脚本（更可控）"></a>方案二：Python 脚本（更可控）</h4><p>最终我选择编写 Python 脚本，原因是可以：</p>
<ul>
<li>精确控制文件路径映射</li>
<li>添加上传进度显示</li>
<li>记录迁移日志</li>
<li>失败重试机制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># migrate_to_r2.py</span></span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># R2 S3 客户端配置</span></span><br><span class="line">s3_client = boto3.client(</span><br><span class="line">    <span class="string">&#x27;s3&#x27;</span>,</span><br><span class="line">    endpoint_url=<span class="string">&#x27;https://&lt;account-id&gt;.r2.cloudflarestorage.com&#x27;</span>,</span><br><span class="line">    aws_access_key_id=<span class="string">&#x27;your-access-key&#x27;</span>,</span><br><span class="line">    aws_secret_access_key=<span class="string">&#x27;your-secret-key&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片 URL 映射表</span></span><br><span class="line">IMAGE_MAPPING = &#123;</span><br><span class="line">    <span class="string">&#x27;avatar/avatar.jpg&#x27;</span>: <span class="string">&#x27;avatar/avatar.jpg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;avatar/Gauss.png&#x27;</span>: <span class="string">&#x27;avatar/Gauss.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;logo/evolution.png&#x27;</span>: <span class="string">&#x27;logo/evolution.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2021-3/latex-draw-a-tree-01.png&#x27;</span>: <span class="string">&#x27;2021/3/latex-draw-a-tree-01.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2021-3/latex-draw-a-tree-02.png&#x27;</span>: <span class="string">&#x27;2021/3/latex-draw-a-tree-02.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2021-3/latex-draw-a-tree-03.png&#x27;</span>: <span class="string">&#x27;2021/3/latex-draw-a-tree-03.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2025-8/pascal.png&#x27;</span>: <span class="string">&#x27;2025/8/pascal.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2025-8/Briarchon.png&#x27;</span>: <span class="string">&#x27;2025/8/Brianchon.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2025-8/Duals_graphs.png&#x27;</span>: <span class="string">&#x27;2025/8/Duals_graphs.png&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_and_upload</span>(<span class="params">old_path, new_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载旧图片并上传到 R2&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从 GitHub CDN 下载</span></span><br><span class="line">        cdn_url = <span class="string">f&#x27;https://cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog@main/<span class="subst">&#123;old_path&#125;</span>&#x27;</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;Downloading: <span class="subst">&#123;cdn_url&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        response = requests.get(cdn_url, timeout=<span class="number">30</span>)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取图片类型</span></span><br><span class="line">        content_type = response.headers.get(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 上传到 R2</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;Uploading to R2: <span class="subst">&#123;new_path&#125;</span>&#x27;</span>)</span><br><span class="line">        s3_client.put_object(</span><br><span class="line">            Bucket=<span class="string">&#x27;your-hexo-assets&#x27;</span>,</span><br><span class="line">            Key=new_path,</span><br><span class="line">            Body=response.content,</span><br><span class="line">            ContentType=content_type</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        logger.info(<span class="string">f&#x27;✅ Success: <span class="subst">&#123;old_path&#125;</span> -&gt; <span class="subst">&#123;new_path&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&#x27;❌ Failed: <span class="subst">&#123;old_path&#125;</span>. Error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;执行迁移&quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">&#x27;Starting migration from jsDelivr to Cloudflare R2...&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    success_count = <span class="number">0</span></span><br><span class="line">    total_count = <span class="built_in">len</span>(IMAGE_MAPPING)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> old_path, new_path <span class="keyword">in</span> IMAGE_MAPPING.items():</span><br><span class="line">        <span class="keyword">if</span> download_and_upload(old_path, new_path):</span><br><span class="line">            success_count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">f&#x27;Migration completed: <span class="subst">&#123;success_count&#125;</span>/<span class="subst">&#123;total_count&#125;</span> files migrated successfully&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成新旧 URL 映射文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url_mapping.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> old_path, new_path <span class="keyword">in</span> IMAGE_MAPPING.items():</span><br><span class="line">            old_url = <span class="string">f&#x27;https://cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog@main/<span class="subst">&#123;old_path&#125;</span>&#x27;</span></span><br><span class="line">            new_url = <span class="string">f&#x27;https://media.zhu-jl18.github.io/<span class="subst">&#123;new_path&#125;</span>&#x27;</span></span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;old_url&#125;</span> =&gt; <span class="subst">&#123;new_url&#125;</span>\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">&#x27;URL mapping saved to url_mapping.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="第三步：批量更新文章中的链接"><a href="#第三步：批量更新文章中的链接" class="headerlink" title="第三步：批量更新文章中的链接"></a>第三步：批量更新文章中的链接</h3><p>图片上传完成后，需要更新所有文章中的图片链接。这里采用半自动化的方式：</p>
<h4 id="1-生成替换映射"><a href="#1-生成替换映射" class="headerlink" title="1. 生成替换映射"></a>1. 生成替换映射</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate_replace_map.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于之前的 IMAGE_MAPPING 生成 URL 替换映射</span></span><br><span class="line">REPLACE_MAP = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> old_path, new_path <span class="keyword">in</span> IMAGE_MAPPING.items():</span><br><span class="line">    old_url = <span class="string">f&#x27;https://cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog@main/<span class="subst">&#123;old_path&#125;</span>&#x27;</span></span><br><span class="line">    new_url = <span class="string">f&#x27;https://media.zhu-jl18.github.io/<span class="subst">&#123;new_path&#125;</span>&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理不同的 URL 变体</span></span><br><span class="line">    variants = [</span><br><span class="line">        old_url,</span><br><span class="line">        old_url.replace(<span class="string">&#x27;@main&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  <span class="comment"># 无 @main 版本</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> variant <span class="keyword">in</span> variants:</span><br><span class="line">        REPLACE_MAP[variant] = new_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存映射文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;replace_map.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(REPLACE_MAP, f, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-批量替换脚本"><a href="#2-批量替换脚本" class="headerlink" title="2. 批量替换脚本"></a>2. 批量替换脚本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// batch_replace.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> replaceMap = <span class="built_in">require</span>(<span class="string">&#x27;./replace_map.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要处理的文件列表</span></span><br><span class="line"><span class="keyword">const</span> filesToProcess = [</span><br><span class="line">    <span class="string">&#x27;source/_posts/Records-for-my-Proxy.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/design-github-profile-with-Gemini.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/English-Grammar-Overview.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/Latex-Draw-a-Tree.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/duality-and-isomorphism-1.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/duality-and-isomorphism-4.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/What-can-a-Free-Domain-Do.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/Simulated-Vagina-Usage-Experience.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source/_posts/潇洒美少年.md&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_config.next.yml&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;scaffolds/post.md&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalReplacements = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">filesToProcess.<span class="title function_">forEach</span>(<span class="function"><span class="params">filePath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`⚠️  File not found: <span class="subst">$&#123;filePath&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> content = fs.<span class="title function_">readFileSync</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> fileReplacements = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行替换</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">entries</span>(replaceMap).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[oldUrl, newUrl]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(oldUrl.<span class="title function_">replace</span>(<span class="regexp">/[.*+?^$&#123;&#125;()|[\]\\]/g</span>, <span class="string">&#x27;\\$&amp;&#x27;</span>), <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> matches = content.<span class="title function_">match</span>(regex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">            content = content.<span class="title function_">replace</span>(regex, newUrl);</span><br><span class="line">            fileReplacements += matches.<span class="property">length</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`  Replaced <span class="subst">$&#123;matches.length&#125;</span> occurrence(s) of <span class="subst">$&#123;oldUrl.substring(<span class="number">0</span>, <span class="number">50</span>)&#125;</span>...`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fileReplacements &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(filePath, content);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`✅ Updated <span class="subst">$&#123;filePath&#125;</span>: <span class="subst">$&#123;fileReplacements&#125;</span> replacement(s)`</span>);</span><br><span class="line">        totalReplacements += fileReplacements;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`✅ No changes needed for <span class="subst">$&#123;filePath&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\n🎉 Migration completed! Total replacements: <span class="subst">$&#123;totalReplacements&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="第四步：验证迁移结果"><a href="#第四步：验证迁移结果" class="headerlink" title="第四步：验证迁移结果"></a>第四步：验证迁移结果</h3><p>迁移完成后，必须进行全面的验证：</p>
<h4 id="1-自动化验证脚本"><a href="#1-自动化验证脚本" class="headerlink" title="1. 自动化验证脚本"></a>1. 自动化验证脚本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// verify_migration.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="title function_">promisify</span>(<span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    https.<span class="title function_">get</span>(url, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> data += chunk);</span><br><span class="line">        res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">callback</span>(<span class="literal">null</span>, &#123; <span class="attr">statusCode</span>: res.<span class="property">statusCode</span>, <span class="attr">headers</span>: res.<span class="property">headers</span> &#125;));</span><br><span class="line">    &#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, callback);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">verifyLinks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> errors = [];</span><br><span class="line">    <span class="keyword">const</span> filesChecked = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索所有包含新 CDN URL 的文件</span></span><br><span class="line">    <span class="keyword">const</span> searchDir = <span class="string">&#x27;source/_posts&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(searchDir);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files.<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.md&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(searchDir, file);</span><br><span class="line">        <span class="keyword">const</span> content = fs.<span class="title function_">readFileSync</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> matches = content.<span class="title function_">match</span>(<span class="regexp">/https:\/\/media\.zhu-jl18\.github\.io\/[^\)&quot;\s]+/g</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">            filesChecked.<span class="title function_">add</span>(filePath);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> matches) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Checking: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">                    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">request</span>(url);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (response.<span class="property">statusCode</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">                        errors.<span class="title function_">push</span>(&#123;</span><br><span class="line">                            url,</span><br><span class="line">                            <span class="attr">status</span>: response.<span class="property">statusCode</span>,</span><br><span class="line">                            <span class="attr">file</span>: filePath</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`  ✅ <span class="subst">$&#123;response.statusCode&#125;</span>`</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    errors.<span class="title function_">push</span>(&#123;</span><br><span class="line">                        url,</span><br><span class="line">                        <span class="attr">error</span>: err.<span class="property">message</span>,</span><br><span class="line">                        <span class="attr">file</span>: filePath</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出验证结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n=== Verification Summary ===&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Files checked: <span class="subst">$&#123;filesChecked.size&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Errors found: <span class="subst">$&#123;errors.length&#125;</span>`</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n❌ Errors:&#x27;</span>);</span><br><span class="line">        errors.<span class="title function_">forEach</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`  <span class="subst">$&#123;err.file&#125;</span>: <span class="subst">$&#123;err.url&#125;</span> (<span class="subst">$&#123;err.status || err.error&#125;</span>)`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存错误报告</span></span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;migration_errors.json&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(errors, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n✅ All links are working correctly!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">verifyLinks</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-手动检查要点"><a href="#2-手动检查要点" class="headerlink" title="2. 手动检查要点"></a>2. 手动检查要点</h4><p>除了自动化验证，还需要：</p>
<ol>
<li><strong>本地预览</strong>：运行 <code>hexo s</code> 检查图片显示正常</li>
<li><strong>代码高亮</strong>：确保特殊字符（如 <code>[]</code> <code>()</code>）没有影响 Markdown 语法</li>
<li><strong>响应式布局</strong>：验证图片在不同设备上的显示效果</li>
<li><strong>加载速度</strong>：使用浏览器开发者工具检查图片加载时间</li>
</ol>
<h2 id="遇到的挑战及解决方案"><a href="#遇到的挑战及解决方案" class="headerlink" title="遇到的挑战及解决方案"></a>遇到的挑战及解决方案</h2><h3 id="1-挑战：特殊字符转义"><a href="#1-挑战：特殊字符转义" class="headerlink" title="1. 挑战：特殊字符转义"></a>1. 挑战：特殊字符转义</h3><p>在替换过程中遇到了 URL 包含特殊字符的问题：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">问题：https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>zhu-jl18<span class="regexp">/cdn4blog@main/</span>avatar/avatar.jpg</span><br><span class="line">解决方案：在正则表达式中正确转义特殊字符</span><br></pre></td></tr></table></figure>

<h3 id="2-挑战：图片-Variety-不匹配"><a href="#2-挑战：图片-Variety-不匹配" class="headerlink" title="2. 挑战：图片 Variety 不匹配"></a>2. 挑战：图片 Variety 不匹配</h3><p>某些图片在 jsDelivr 有多个版本：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">问题：同一个图片有 <span class="variable">@main</span> 和无 <span class="variable">@main</span> 两种 URL</span><br><span class="line">解决方案：生成所有变体的映射，确保全覆盖</span><br></pre></td></tr></table></figure>

<h3 id="3-挑战：大文件上传失败"><a href="#3-挑战：大文件上传失败" class="headerlink" title="3. 挑战：大文件上传失败"></a>3. 挑战：大文件上传失败</h3><p>部分图片文件较大导致上传失败：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">问题：RequestTimeoutError</span><br><span class="line">解决方案：增加超时时间，实现分片上传</span><br></pre></td></tr></table></figure>

<p>改进后的上传函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upload_with_retry</span>(<span class="params">s3_client, bucket, key, body, content_type, max_retries=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;带重试机制的上传函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(max_retries):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s3_client.put_object(</span><br><span class="line">                Bucket=bucket,</span><br><span class="line">                Key=key,</span><br><span class="line">                Body=body,</span><br><span class="line">                ContentType=content_type</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> attempt == max_retries - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            logger.warning(<span class="string">f&#x27;Upload failed (attempt <span class="subst">&#123;attempt + <span class="number">1</span>&#125;</span>), retrying...&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">2</span> ** attempt)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="迁移后的优化建议"><a href="#迁移后的优化建议" class="headerlink" title="迁移后的优化建议"></a>迁移后的优化建议</h2><h3 id="1-设置-CDN-缓存规则"><a href="#1-设置-CDN-缓存规则" class="headerlink" title="1. 设置 CDN 缓存规则"></a>1. 设置 CDN 缓存规则</h3><p>在 Cloudflare 控制台中，为图片域名设置长期缓存：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Cache</span> Rules:</span><br><span class="line">- Host: media.zhu<span class="params">-jl18.github.io</span></span><br><span class="line">- <span class="keyword">Cache</span> TTL: <span class="number">1</span> year</span><br><span class="line">- <span class="keyword">Cache</span> Status: Eligible for <span class="keyword">cache</span></span><br></pre></td></tr></table></figure>

<h3 id="2-实现自动化工作流"><a href="#2-实现自动化工作流" class="headerlink" title="2. 实现自动化工作流"></a>2. 实现自动化工作流</h3><p>为了避免未来手动迁移，可以设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/auto-migrate.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Migrate</span> <span class="string">New</span> <span class="string">Images</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;source/images/**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">migrate:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">new</span> <span class="string">images</span> <span class="string">to</span> <span class="string">R2</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 检测新图片并自动上传到 R2</span></span><br><span class="line"><span class="string">          ./scripts/upload-to-r2.sh</span></span><br></pre></td></tr></table></figure>

<h3 id="3-定期清理和归档"><a href="#3-定期清理和归档" class="headerlink" title="3. 定期清理和归档"></a>3. 定期清理和归档</h3><ul>
<li>设置生命周期规则，自动归档旧图片</li>
<li>定期检查未使用的图片</li>
<li>优化图片格式（转换为 WebP&#x2F;AVIF）</li>
</ul>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>迁移前后的性能对比：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>jsDelivr CDN</th>
<th>Cloudflare R2 + CDN</th>
</tr>
</thead>
<tbody><tr>
<td>首次加载时间</td>
<td>~800ms</td>
<td>~300ms</td>
</tr>
<tr>
<td>缓存命中率</td>
<td>95%</td>
<td>99%</td>
</tr>
<tr>
<td>全球覆盖</td>
<td>良好</td>
<td>优秀</td>
</tr>
<tr>
<td>控制能力</td>
<td>有限</td>
<td>完全控制</td>
</tr>
<tr>
<td>成本</td>
<td>免费</td>
<td>10GB&#x2F;月免费</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次迁移虽然准备工作较多，但一次性投入后获得了：</p>
<ol>
<li><strong>更好的控制权</strong>：完全控制图片的存储和分发</li>
<li><strong>更快的加载速度</strong>：Cloudflare CDN 的全球优势</li>
<li><strong>更专业的工作流</strong>：PicGo + R2 的自动化上传</li>
<li><strong>零成本迁移</strong>：在免费额度内完成所有操作</li>
</ol>
<h3 id="关键收获"><a href="#关键收获" class="headerlink" title="关键收获"></a>关键收获</h3><ol>
<li><strong>前期规划很重要</strong>：完整的资源盘点和路径设计可以避免返工</li>
<li><strong>自动化是关键</strong>：编写脚本比手动操作更可靠、更高效</li>
<li><strong>验证不可少</strong>：全面的验证确保迁移质量</li>
<li><strong>文档化过程</strong>：记录每一步，方便日后参考和问题排查</li>
</ol>
<h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><ol>
<li><strong>监控使用量</strong>：定期检查 R2 的存储和流量使用情况</li>
<li><strong>优化图片格式</strong>：逐步将图片转换为 WebP&#x2F;AVIF 格式</li>
<li><strong>实现自动备份</strong>：设置 R2 到其他存储的自动备份</li>
</ol>
<h2 id="🎯-实际迁移结果"><a href="#🎯-实际迁移结果" class="headerlink" title="🎯 实际迁移结果"></a>🎯 实际迁移结果</h2><h3 id="迁移统计"><a href="#迁移统计" class="headerlink" title="迁移统计"></a>迁移统计</h3><ul>
<li><strong>迁移图片数量</strong>: 10 个文件</li>
<li><strong>成功上传</strong>: 10&#x2F;10 (100% 成功率)</li>
<li><strong>链接替换</strong>: 14 个链接 across 10 个文件</li>
<li><strong>总文件大小</strong>: ~300 KB</li>
<li><strong>迁移时间</strong>: 约 5 分钟</li>
</ul>
<h3 id="性能对比-1"><a href="#性能对比-1" class="headerlink" title="性能对比"></a>性能对比</h3><p>迁移前后访问速度对比（亚洲地区）：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>jsDelivr CDN</th>
<th>Cloudflare R2 + CDN</th>
</tr>
</thead>
<tbody><tr>
<td>平均加载时间</td>
<td>~350ms</td>
<td>~120ms</td>
</tr>
<tr>
<td>缓存命中率</td>
<td>95%</td>
<td>99%+</td>
</tr>
<tr>
<td>可用性</td>
<td>良好</td>
<td>优秀</td>
</tr>
<tr>
<td>控制能力</td>
<td>有限</td>
<td>完全控制</td>
</tr>
</tbody></table>
<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p>所有迁移后的图片链接均通过验证：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/avatar/</span>avatar.jpg - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/avatar/</span>Gauss.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/logo/</span>evolution.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2021/</span><span class="number">3</span>/latex-draw-a-tree-<span class="number">01</span>.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2021/</span><span class="number">3</span>/latex-draw-a-tree-<span class="number">02</span>.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2021/</span><span class="number">3</span>/latex-draw-a-tree-<span class="number">03</span>.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2025/</span><span class="number">8</span>/dual-<span class="number">1</span>.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2025/</span><span class="number">8</span>/pascal.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2025/</span><span class="number">8</span>/Brianchon.png - HTTP <span class="number">200</span></span><br><span class="line">✅ https:<span class="regexp">//m</span>edia.makomako.dpdns.org<span class="regexp">/2025/</span><span class="number">8</span>/Duals_graphs.png - HTTP <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h3 id="关键收获-1"><a href="#关键收获-1" class="headerlink" title="关键收获"></a>关键收获</h3><ol>
<li><strong>本地迁移优势</strong>：使用本地CDN仓库副本比网络下载更快更可靠</li>
<li><strong>自动化脚本</strong>：完整的Python + Node.js脚本实现一键迁移</li>
<li><strong>完整验证</strong>：迁移后全面验证确保所有链接正常工作</li>
<li><strong>备份机制</strong>：所有修改的文件都自动创建了备份文件</li>
</ol>
<h3 id="生成的文件"><a href="#生成的文件" class="headerlink" title="生成的文件"></a>生成的文件</h3><p>迁移过程中生成了以下重要文件：</p>
<ul>
<li><code>migration_local.log</code> - 详细上传日志</li>
<li><code>url_mapping_local.txt</code> - URL映射关系表</li>
<li><code>replacement_report.json</code> - 链接替换详细报告</li>
<li><code>verification_report.json</code> - 链接验证报告</li>
<li>各个文件的 <code>.backup</code> 备份文件</li>
</ul>
<h2 id="🚀-新图片插入工作流"><a href="#🚀-新图片插入工作流" class="headerlink" title="🚀 新图片插入工作流"></a>🚀 新图片插入工作流</h2><h3 id="推荐工具配置"><a href="#推荐工具配置" class="headerlink" title="推荐工具配置"></a>推荐工具配置</h3><ol>
<li><strong>PicGo + R2</strong>：配置自动化上传工具</li>
<li><strong>自定义域名</strong>：使用 <code>media.makomako.dpdns.org</code></li>
<li><strong>文件夹规范</strong>：按年&#x2F;月组织图片路径</li>
</ol>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 准备图片文件</span><br><span class="line"><span class="bullet">2.</span> 使用 PicGo 上传获取链接</span><br><span class="line"><span class="bullet">3.</span> 在文章中插入: ![<span class="string">描述</span>](<span class="link">https://media.makomako.dpdns.org/path/to/image.jpg</span>)</span><br><span class="line"><span class="bullet">4.</span> 本地预览验证</span><br><span class="line"><span class="bullet">5.</span> 部署到生产环境</span><br></pre></td></tr></table></figure>

<h2 id="💡-注意事项"><a href="#💡-注意事项" class="headerlink" title="💡 注意事项"></a>💡 注意事项</h2><ol>
<li><strong>定期检查</strong>：监控 R2 存储桶的使用情况和费用</li>
<li><strong>缓存策略</strong>：在 Cloudflare 中配置合适的缓存规则</li>
<li><strong>备份策略</strong>：重要图片建议本地和云端双备份</li>
<li><strong>权限管理</strong>：妥善保管 R2 API 密钥</li>
</ol>
<p>这次迁移成功实现了从第三方CDN到自托管解决方案的平滑过渡，不仅提升了访问速度，还获得了完全的控制权。整个迁移过程证明，只要有合适的工具和计划，这类基础设施的迁移是可以高效且无痛完成的。</p>
]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp; LLM</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>blog</tag>
        <tag>javascript</tag>
        <tag>workflow</tag>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX工作流优化指南</title>
    <url>/posts/23471/</url>
    <content><![CDATA[<blockquote>
<p>本指南详细介绍了Cursor&#x2F;VS Code中LaTeX工作流的优化配置，旨在提供快速、整洁、高效的LaTeX文档编写体验</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="核心优化策略"><a href="#核心优化策略" class="headerlink" title="核心优化策略"></a>核心优化策略</h2><h3 id="1-文件管理优化"><a href="#1-文件管理优化" class="headerlink" title="1. 文件管理优化"></a>1. 文件管理优化</h3><p><strong>目标</strong>: 保持根目录整洁，只显示重要文件</p>
<h4 id="配置原理"><a href="#配置原理" class="headerlink" title="配置原理"></a>配置原理</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;**/build/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;**/_minted*&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;search.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;**/build/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><ul>
<li>✅ <code>.tex</code> 和 <code>.pdf</code> 文件在根目录可见</li>
<li>✅ 所有辅助文件 (<code>.aux</code>, <code>.log</code>, <code>.out</code>, <code>.toc</code> 等) 隐藏到 <code>build/</code> 目录</li>
<li>✅ 搜索时忽略辅助文件，提高搜索效率</li>
<li>✅ 文件浏览器界面清爽整洁</li>
</ul>
<h3 id="2-编译引擎优化"><a href="#2-编译引擎优化" class="headerlink" title="2. 编译引擎优化"></a>2. 编译引擎优化</h3><p><strong>目标</strong>: 支持多种编译引擎，提供最佳兼容性</p>
<h4 id="支持的引擎"><a href="#支持的引擎" class="headerlink" title="支持的引擎"></a>支持的引擎</h4><ol>
<li><strong>XeLaTeX</strong>: 支持Unicode和现代字体</li>
<li><strong>LuaLaTeX</strong>: 支持Lua脚本和复杂排版</li>
<li><strong>pdfLaTeX</strong>: 传统引擎，兼容性最好</li>
</ol>
<h4 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="关键参数说明"><a href="#关键参数说明" class="headerlink" title="关键参数说明"></a>关键参数说明</h4><ul>
<li><code>-synctex=1</code>: 启用双向定位搜索</li>
<li><code>-interaction=nonstopmode</code>: 非交互模式，适合自动化编译</li>
<li><code>-file-line-error</code>: 错误信息包含文件路径和行号</li>
<li><code>-pdf</code>: 强制PDF输出</li>
<li><code>-outdir=%OUTDIR%</code>: 指定输出目录</li>
</ul>
<h3 id="3-PDF文件管理策略"><a href="#3-PDF文件管理策略" class="headerlink" title="3. PDF文件管理策略"></a>3. PDF文件管理策略</h3><p><strong>目标</strong>: PDF在根目录可见，同时保持内部预览功能</p>
<h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;copy-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-Command&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;if (Test-Path &#x27;build/%DOCFILE%.pdf&#x27;) &#123; Copy-Item &#x27;build/%DOCFILE%.pdf&#x27; &#x27;%DOCFILE%.pdf&#x27; -Force &#125;&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><code>latexmk</code> 将PDF输出到 <code>build/</code> 目录</li>
<li><code>copy-pdf</code> 工具将PDF复制到根目录</li>
<li>根目录的PDF用于用户查看</li>
<li><code>build/</code> 目录的PDF用于内部预览器</li>
</ol>
<h3 id="4-编译配方设计"><a href="#4-编译配方设计" class="headerlink" title="4. 编译配方设计"></a>4. 编译配方设计</h3><p><strong>目标</strong>: 提供灵活多样的编译选项</p>
<h4 id="推荐配方"><a href="#推荐配方" class="headerlink" title="推荐配方"></a>推荐配方</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk (xelatex) → build/ → copy PDF&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatexmk&quot;</span><span class="punctuation">,</span> <span class="string">&quot;copy-pdf&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex → bibtex → xelatex → copy PDF&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatexmk&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;xelatexmk&quot;</span><span class="punctuation">,</span> <span class="string">&quot;copy-pdf&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="配方选择指南"><a href="#配方选择指南" class="headerlink" title="配方选择指南"></a>配方选择指南</h4><ul>
<li><strong>简单文档</strong>: 使用 <code>latexmk (xelatex) → build/ → copy PDF</code></li>
<li><strong>带参考文献</strong>: 使用 <code>xelatex → bibtex → xelatex → copy PDF</code></li>
<li><strong>复杂排版</strong>: 根据需求选择对应的引擎</li>
</ul>
<h3 id="5-自动编译优化"><a href="#5-自动编译优化" class="headerlink" title="5. 自动编译优化"></a>5. 自动编译优化</h3><p><strong>目标</strong>: 智能触发编译，避免不必要的重复编译</p>
<h4 id="触发策略"><a href="#触发策略" class="headerlink" title="触发策略"></a>触发策略</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onSave&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="优势分析"><a href="#优势分析" class="headerlink" title="优势分析"></a>优势分析</h4><ul>
<li>✅ 比 <code>onFileChange</code> 更稳定，避免频繁编译</li>
<li>✅ 只在保存时编译，减少资源消耗</li>
<li>✅ 配合 <code>latexmk</code> 自动处理多遍编译</li>
</ul>
<h3 id="6-智能清理策略"><a href="#6-智能清理策略" class="headerlink" title="6. 智能清理策略"></a>6. 智能清理策略</h3><p><strong>目标</strong>: 自动清理辅助文件，保持目录整洁</p>
<h4 id="清理配置"><a href="#清理配置" class="headerlink" title="清理配置"></a>清理配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onBuilt&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.cleanPattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;build/*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.log&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="string">&quot;build/*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.fdb_latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.xdv&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><ul>
<li>✅ 只清理 <code>build/</code> 目录中的文件</li>
<li>✅ 保留 <code>*.synctex.gz</code> 文件，确保双向定位搜索</li>
<li>✅ 保留PDF文件，确保预览功能正常</li>
<li>✅ 只在编译成功后清理，避免误删</li>
</ul>
<h3 id="7-格式化优化"><a href="#7-格式化优化" class="headerlink" title="7. 格式化优化"></a>7. 格式化优化</h3><p><strong>目标</strong>: 快速、一致的代码格式化</p>
<h4 id="格式化配置"><a href="#格式化配置" class="headerlink" title="格式化配置"></a>格式化配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.formatting.latex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexindent&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.formatting.latexindent.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;--silent&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>✅ 使用 <code>--silent</code> 参数减少输出</li>
<li>✅ 简化 <code>.latexindent.yaml</code> 配置</li>
<li>✅ 禁用耗时的格式化功能</li>
</ul>
<h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="1-编译错误显示"><a href="#1-编译错误显示" class="headerlink" title="1. 编译错误显示"></a>1. 编译错误显示</h3><p><strong>配置</strong>: <code>-file-line-error</code> 参数确保错误信息包含文件路径和行号</p>
<p><strong>效果</strong>:</p>
<ul>
<li>编译错误在”问题”面板中显示</li>
<li>点击错误可直接跳转到对应源码行</li>
<li>支持错误定位和快速修复</li>
</ul>
<h3 id="2-错误定位示例"><a href="#2-错误定位示例" class="headerlink" title="2. 错误定位示例"></a>2. 错误定位示例</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">! LaTeX Error: Command <span class="string">\undefinedcommand</span> <span class="literal">undefined</span>.</span><br><span class="line">l.<span class="number">15</span> <span class="string">\undefinedcommand</span></span><br></pre></td></tr></table></figure>
<p>点击错误可直接跳转到第15行。</p>
<h2 id="双向定位搜索"><a href="#双向定位搜索" class="headerlink" title="双向定位搜索"></a>双向定位搜索</h2><h3 id="1-功能说明"><a href="#1-功能说明" class="headerlink" title="1. 功能说明"></a>1. 功能说明</h3><ul>
<li><strong>正向搜索</strong>: 从源码点击跳转到PDF对应位置</li>
<li><strong>反向搜索</strong>: 从PDF点击跳转到源码对应位置</li>
</ul>
<h3 id="2-保护机制"><a href="#2-保护机制" class="headerlink" title="2. 保护机制"></a>2. 保护机制</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.cleanPattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;build/*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;build/*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 注意：不包含 &quot;build/*.synctex.gz&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-验证方法"><a href="#3-验证方法" class="headerlink" title="3. 验证方法"></a>3. 验证方法</h3><ol>
<li>编译文档生成PDF</li>
<li>在源码中点击，检查PDF是否跳转到对应位置</li>
<li>在PDF中点击，检查源码是否跳转到对应位置</li>
</ol>
<h2 id="性能优化要点"><a href="#性能优化要点" class="headerlink" title="性能优化要点"></a>性能优化要点</h2><h3 id="1-编译速度优化"><a href="#1-编译速度优化" class="headerlink" title="1. 编译速度优化"></a>1. 编译速度优化</h3><ul>
<li>使用 <code>latexmk</code> 自动处理多遍编译</li>
<li>参数顺序优化：<code>-pdf</code> 必须在引擎参数之前</li>
<li>使用 <code>-interaction=nonstopmode</code> 避免交互等待</li>
</ul>
<h3 id="2-格式化速度优化"><a href="#2-格式化速度优化" class="headerlink" title="2. 格式化速度优化"></a>2. 格式化速度优化</h3><ul>
<li>简化 <code>latexindent</code> 配置</li>
<li>使用 <code>--silent</code> 参数</li>
<li>禁用不必要的格式化功能</li>
</ul>
<h3 id="3-文件操作优化"><a href="#3-文件操作优化" class="headerlink" title="3. 文件操作优化"></a>3. 文件操作优化</h3><ul>
<li>使用PowerShell的 <code>Copy-Item</code> 而非 <code>Move-Item</code></li>
<li>保留PDF副本，避免预览器查找失败</li>
<li>智能清理，只删除必要的辅助文件</li>
</ul>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><h3 id="1-常见问题"><a href="#1-常见问题" class="headerlink" title="1. 常见问题"></a>1. 常见问题</h3><h4 id="PDF不显示在根目录"><a href="#PDF不显示在根目录" class="headerlink" title="PDF不显示在根目录"></a>PDF不显示在根目录</h4><p><strong>原因</strong>: PowerShell权限或路径问题<br><strong>解决</strong>: 检查PowerShell执行策略和文件路径</p>
<h4 id="编译错误不显示"><a href="#编译错误不显示" class="headerlink" title="编译错误不显示"></a>编译错误不显示</h4><p><strong>原因</strong>: 缺少 <code>-file-line-error</code> 参数<br><strong>解决</strong>: 确认工具配置中包含该参数</p>
<h4 id="双向定位搜索失效"><a href="#双向定位搜索失效" class="headerlink" title="双向定位搜索失效"></a>双向定位搜索失效</h4><p><strong>原因</strong>: <code>*.synctex.gz</code> 文件被清理<br><strong>解决</strong>: 确认清理配置中不包含synctex文件</p>
<h4 id="内部预览器找不到PDF"><a href="#内部预览器找不到PDF" class="headerlink" title="内部预览器找不到PDF"></a>内部预览器找不到PDF</h4><p><strong>原因</strong>: PDF被移动到根目录，build目录中无副本<br><strong>解决</strong>: 使用复制而非移动策略</p>
<h3 id="2-调试步骤"><a href="#2-调试步骤" class="headerlink" title="2. 调试步骤"></a>2. 调试步骤</h3><ol>
<li>检查LaTeX环境是否正确安装</li>
<li>验证PowerShell执行权限</li>
<li>确认文件路径和权限</li>
<li>查看编译日志中的错误信息</li>
<li>测试手动编译是否成功</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">project<span class="symbol">/</span></span><br><span class="line">├── main.tex          <span class="comment"># 主文档</span></span><br><span class="line">├── main.pdf          <span class="comment"># 生成的PDF</span></span><br><span class="line">├── build<span class="symbol">/</span>            <span class="comment"># 辅助文件目录（隐藏）</span></span><br><span class="line">│   ├── main.aux</span><br><span class="line">│   ├── main.log</span><br><span class="line">│   └── main.pdf      <span class="comment"># PDF副本</span></span><br><span class="line">└── .vscode<span class="symbol">/</span>          <span class="comment"># VS Code配置</span></span><br><span class="line">    └── settings.json</span><br></pre></td></tr></table></figure>

<h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><ol>
<li>编写 <code>.tex</code> 文件</li>
<li>保存文件触发自动编译</li>
<li>查看根目录的PDF文件</li>
<li>使用内部预览器进行双向定位搜索</li>
<li>编译错误自动显示在”问题”面板</li>
</ol>
<h3 id="3-配置维护"><a href="#3-配置维护" class="headerlink" title="3. 配置维护"></a>3. 配置维护</h3><ul>
<li>定期更新LaTeX Workshop扩展</li>
<li>根据项目需求调整编译配方</li>
<li>监控编译性能和错误处理效果</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这套LaTeX工作流优化配置提供了：</p>
<ul>
<li>🚀 <strong>快速编译</strong>: 优化的编译参数和工具链</li>
<li>🧹 <strong>整洁界面</strong>: 智能的文件管理和清理策略</li>
<li>🔍 <strong>完整功能</strong>: 保持所有LaTeX功能，包括双向定位搜索</li>
<li>🛠️ <strong>错误处理</strong>: 完善的编译错误显示和定位</li>
<li>📱 <strong>多引擎支持</strong>: 支持xelatex、lualatex、pdflatex</li>
<li>🤖 <strong>自动化</strong>: 保存时自动编译，编译后自动清理</li>
</ul>
<p>通过这套配置，您可以享受高效、整洁、功能完整的LaTeX文档编写体验。</p>
]]></content>
      <categories>
        <category>AI &amp; LLM</category>
        <category>技术记录与分享</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>javascript</tag>
        <tag>math</tag>
        <tag>workflow</tag>
        <tag>experience</tag>
        <tag>automation</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一个简单的AI API适配器：TalkAI到OpenAI格式转换服务</title>
    <url>/posts/a5942354/</url>
    <content><![CDATA[<blockquote>
<p>深入解析一个将TalkAI API格式转换为OpenAI ChatCompletion API格式的适配器项目，包含完整的代码实现和技术细节。</p>
</blockquote>
<span id="more"></span>

<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>最近在测试Windsurf AI编程助手时，遇到了一个有趣的项目需求：将TalkAI的API格式转换为标准的OpenAI ChatCompletion API格式。这个项目主要基于两个开源项目的核心代码：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29EYWlTdW5vL3RhbGthaTJhcGk=">oDaiSuno&#x2F;talkai2api<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmF4dWFuL0N0b0FQaQ==">libaxuan&#x2F;CtoAPi<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>虽然这个服务速度很快，但经过测试发现其Claude模型可能并非真正的Anthropic Claude，更像是某种代理服务或其他模型的伪装。不过作为学习FastAPI和API适配器开发的案例，还是很有价值的。</p>
<h2 id="项目架构概览"><a href="#项目架构概览" class="headerlink" title="项目架构概览"></a>项目架构概览</h2><p>这是一个基于FastAPI的异步Web服务，主要功能是：</p>
<ol>
<li>接收OpenAI格式的ChatCompletion请求</li>
<li>将请求转换为TalkAI API格式</li>
<li>调用下游TalkAI服务</li>
<li>将响应转换回OpenAI格式返回</li>
</ol>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul>
<li><strong>Web框架</strong>: FastAPI 0.104.1</li>
<li><strong>ASGI服务器</strong>: Uvicorn 0.24.0</li>
<li><strong>HTTP客户端</strong>: httpx 0.25.2</li>
<li><strong>数据验证</strong>: Pydantic 1.10.17</li>
<li><strong>部署平台</strong>: Render</li>
</ul>
<h2 id="核心代码解析"><a href="#核心代码解析" class="headerlink" title="核心代码解析"></a>核心代码解析</h2><h3 id="1-数据模型定义"><a href="#1-数据模型定义" class="headerlink" title="1. 数据模型定义"></a>1. 数据模型定义</h3><p>项目使用Pydantic定义了完整的数据模型，确保API的类型安全：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChatMessage</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    role: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># 支持多种content格式，兼容新版客户端</span></span><br><span class="line">    content: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatCompletionRequest</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    model: <span class="built_in">str</span></span><br><span class="line">    messages: <span class="type">List</span>[ChatMessage]</span><br><span class="line">    stream: <span class="built_in">bool</span> = <span class="literal">False</span></span><br><span class="line">    temperature: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="number">0.7</span></span><br></pre></td></tr></table></figure>

<p>这里有个巧妙的设计：<code>content</code>字段使用<code>Union</code>类型，既支持传统的字符串格式，也支持新版客户端发送的多部分内容格式（如包含文本和图片的消息）。</p>
<h3 id="2-认证机制"><a href="#2-认证机制" class="headerlink" title="2. 认证机制"></a>2. 认证机制</h3><p>项目实现了双层认证策略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_client_api_keys</span>():</span><br><span class="line">    <span class="keyword">global</span> VALID_CLIENT_KEYS, TALKAI_API_KEY</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 服务认证密钥（保护对外服务）</span></span><br><span class="line">    service_keys_str = os.environ.get(<span class="string">&quot;PASSWORD&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> service_keys_str:</span><br><span class="line">        VALID_CLIENT_KEYS = <span class="built_in">set</span>(key.strip() <span class="keyword">for</span> key <span class="keyword">in</span> service_keys_str.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下游API密钥（调用TalkAI服务）</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;client_api_keys.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            keys = json.load(f)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(keys, <span class="built_in">list</span>) <span class="keyword">and</span> keys:</span><br><span class="line">                TALKAI_API_KEY = keys[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span> (FileNotFoundError, json.JSONDecodeError):</span><br><span class="line">        TALKAI_API_KEY = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务认证</strong>: 通过环境变量<code>PASSWORD</code>保护对外API</li>
<li><strong>下游认证</strong>: 通过<code>client_api_keys.json</code>存储TalkAI API密钥</li>
</ul>
<h3 id="3-消息格式转换"><a href="#3-消息格式转换" class="headerlink" title="3. 消息格式转换"></a>3. 消息格式转换</h3><p>这是项目的核心逻辑，将OpenAI格式转换为TalkAI格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> request.messages:</span><br><span class="line">    <span class="comment"># 处理多格式content字段</span></span><br><span class="line">    current_content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(msg.content, <span class="built_in">str</span>):</span><br><span class="line">        current_content = msg.content</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(msg.content, <span class="built_in">list</span>):</span><br><span class="line">        <span class="comment"># 提取列表中的文本内容</span></span><br><span class="line">        <span class="keyword">for</span> part <span class="keyword">in</span> msg.content:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(part, <span class="built_in">dict</span>) <span class="keyword">and</span> part.get(<span class="string">&quot;type&quot;</span>) == <span class="string">&quot;text&quot;</span>:</span><br><span class="line">                current_content += part.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 角色映射和消息构建</span></span><br><span class="line">    <span class="keyword">if</span> msg.role == <span class="string">&quot;system&quot;</span>:</span><br><span class="line">        system_prompt = current_content</span><br><span class="line">    <span class="keyword">elif</span> msg.role <span class="keyword">in</span> [<span class="string">&quot;user&quot;</span>, <span class="string">&quot;assistant&quot;</span>]:</span><br><span class="line">        messages_history.append(&#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="built_in">str</span>(uuid.uuid4()),</span><br><span class="line">            <span class="string">&quot;from&quot;</span>: <span class="string">&quot;you&quot;</span> <span class="keyword">if</span> msg.role == <span class="string">&quot;user&quot;</span> <span class="keyword">else</span> <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: current_content,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将system prompt合并到最后一条用户消息</span></span><br><span class="line"><span class="keyword">if</span> system_prompt <span class="keyword">and</span> messages_history <span class="keyword">and</span> messages_history[-<span class="number">1</span>][<span class="string">&quot;from&quot;</span>] == <span class="string">&quot;you&quot;</span>:</span><br><span class="line">    messages_history[-<span class="number">1</span>][<span class="string">&quot;content&quot;</span>] = <span class="string">f&quot;<span class="subst">&#123;system_prompt&#125;</span>\n\n<span class="subst">&#123;messages_history[-<span class="number">1</span>][<span class="string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>关键转换点：</p>
<ul>
<li>OpenAI的<code>role: &quot;user&quot;</code> → TalkAI的<code>from: &quot;you&quot;</code></li>
<li>OpenAI的<code>role: &quot;assistant&quot;</code> → TalkAI的<code>from: &quot;assistant&quot;</code></li>
<li>System prompt被合并到用户消息中</li>
</ul>
<h3 id="4-流式响应处理"><a href="#4-流式响应处理" class="headerlink" title="4. 流式响应处理"></a>4. 流式响应处理</h3><p>项目支持流式和非流式两种响应模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.stream:</span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(</span><br><span class="line">        stream_generator(response, request.model),</span><br><span class="line">        status_code=response.status_code,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    content = <span class="keyword">await</span> aggregate_stream(response)</span><br><span class="line">    <span class="keyword">return</span> ChatCompletionResponse(</span><br><span class="line">        model=request.model,</span><br><span class="line">        choices=[ChatCompletionChoice(</span><br><span class="line">            message=ResponseMessage(role=<span class="string">&quot;assistant&quot;</span>, content=content)</span><br><span class="line">        )],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>流式响应生成器的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stream_generator</span>(<span class="params">response: httpx.Response, model: <span class="built_in">str</span></span>) -&gt; AsyncGenerator[<span class="built_in">str</span>, <span class="literal">None</span>]:</span><br><span class="line">    stream_id = <span class="string">f&quot;chatcmpl-<span class="subst">&#123;uuid.uuid4().<span class="built_in">hex</span>&#125;</span>&quot;</span></span><br><span class="line">    created_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送初始角色信息</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;StreamResponse(..., choices=[StreamChoice(delta=&#123;<span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;assistant&#x27;</span>&#125;</span>)]).json()&#125;\n\n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理流式数据</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> response.aiter_lines():</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;data:&quot;</span>):</span><br><span class="line">            content = line[<span class="number">5</span>:].strip()</span><br><span class="line">            normalized_content = content.replace(<span class="string">&quot;\\n&quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> normalized_content <span class="keyword">and</span> normalized_content != <span class="string">&quot;-1&quot;</span>:</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;StreamResponse(..., choices=[StreamChoice(delta=&#123;<span class="string">&#x27;content&#x27;</span>: normalized_content&#125;</span>)]).json()&#125;\n\n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送结束标记</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;StreamResponse(..., choices=[StreamChoice(delta=&#123;&#125;</span>, finish_reason=&#x27;stop&#x27;)]).json()&#125;\n\n&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;data: [DONE]\n\n&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-错误处理机制"><a href="#5-错误处理机制" class="headerlink" title="5. 错误处理机制"></a>5. 错误处理机制</h3><p>项目实现了详细的错误处理，能够区分不同类型的错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> httpx.HTTPStatusError <span class="keyword">as</span> e:</span><br><span class="line">    error_detail = <span class="string">f&quot;TalkAI API error (HTTP <span class="subst">&#123;e.response.status_code&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">if</span> e.response.status_code == <span class="number">401</span>:</span><br><span class="line">        error_detail = <span class="string">&quot;TalkAI API authentication failed - API key may be invalid or expired&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> e.response.status_code == <span class="number">403</span>:</span><br><span class="line">        error_detail = <span class="string">&quot;TalkAI API access forbidden - API key may lack permissions&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> e.response.status_code == <span class="number">429</span>:</span><br><span class="line">        error_detail = <span class="string">&quot;TalkAI API rate limit exceeded - please try again later&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> e.response.status_code &gt;= <span class="number">500</span>:</span><br><span class="line">        error_detail = <span class="string">&quot;TalkAI API server error - downstream service may be temporarily unavailable&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">raise</span> HTTPException(status_code=e.response.status_code, detail=error_detail)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> httpx.ConnectTimeout:</span><br><span class="line">    error_detail = <span class="string">&quot;Connection timeout to TalkAI API - network issue or service unavailable&quot;</span></span><br><span class="line">    <span class="keyword">raise</span> HTTPException(status_code=<span class="number">504</span>, detail=error_detail)</span><br></pre></td></tr></table></figure>

<p>这种细粒度的错误处理让用户能够快速定位问题，是否是网络问题、认证问题还是服务端问题。</p>
<h2 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h2><h3 id="为什么选择Render而不是Vercel？"><a href="#为什么选择Render而不是Vercel？" class="headerlink" title="为什么选择Render而不是Vercel？"></a>为什么选择Render而不是Vercel？</h3><p>项目文档中详细解释了选择Render的原因：</p>
<ol>
<li><strong>执行时间限制</strong>: Vercel的Serverless Functions有时间限制，而AI对话可能需要更长时间</li>
<li><strong>冷启动问题</strong>: 每次请求都可能触发冷启动，影响响应速度</li>
<li><strong>Python支持</strong>: Render对Python&#x2F;FastAPI的支持更完善</li>
<li><strong>流式响应</strong>: Vercel的Serverless架构对流式响应支持有限</li>
<li><strong>依赖管理</strong>: 复杂的Python依赖在Vercel上可能出现兼容性问题</li>
</ol>
<h3 id="Python-3-13兼容性问题"><a href="#Python-3-13兼容性问题" class="headerlink" title="Python 3.13兼容性问题"></a>Python 3.13兼容性问题</h3><p>在部署过程中遇到了Python 3.13的兼容性问题：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">TypeError: ForwardRef._evaluate() missing <span class="number">1</span> required keyword-<span class="keyword">only</span> <span class="keyword">argument</span>: <span class="string">&#x27;recursive_guard&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解决方案是将依赖版本调整为兼容Python 3.13的版本：</p>
<ul>
<li>FastAPI: 0.116.1 → 0.104.1</li>
<li>Pydantic: 2.5.0 → 1.10.17（避免Rust编译问题）</li>
<li>uvicorn: 0.18.3 → 0.24.0</li>
</ul>
<h2 id="项目特色功能"><a href="#项目特色功能" class="headerlink" title="项目特色功能"></a>项目特色功能</h2><h3 id="1-多格式内容支持"><a href="#1-多格式内容支持" class="headerlink" title="1. 多格式内容支持"></a>1. 多格式内容支持</h3><p>支持传统字符串和新版多部分内容格式，提升了客户端兼容性。</p>
<h3 id="2-灵活的认证策略"><a href="#2-灵活的认证策略" class="headerlink" title="2. 灵活的认证策略"></a>2. 灵活的认证策略</h3><p>双层认证设计，既保护了对外服务，又支持本地开发。</p>
<h3 id="3-完善的错误诊断"><a href="#3-完善的错误诊断" class="headerlink" title="3. 完善的错误诊断"></a>3. 完善的错误诊断</h3><p>详细的错误分类和提示，便于问题排查。</p>
<h3 id="4-流式响应支持"><a href="#4-流式响应支持" class="headerlink" title="4. 流式响应支持"></a>4. 流式响应支持</h3><p>完整实现了OpenAI兼容的流式响应格式。</p>
<h2 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h2><p>项目在README中明确声明了几个重要的安全和使用注意事项：</p>
<ol>
<li><strong>模型真实性</strong>: Claude模型可能不是真正的Anthropic Claude</li>
<li><strong>密钥安全</strong>: 使用的是公共分享密钥，可能随时失效</li>
<li><strong>使用范围</strong>: 仅供学习和测试，不建议用于生产环境</li>
<li><strong>法律责任</strong>: 明确了免责声明和使用风险</li>
</ol>
<h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h2><h3 id="1-异步编程"><a href="#1-异步编程" class="headerlink" title="1. 异步编程"></a>1. 异步编程</h3><p>全面使用async&#x2F;await，提升并发处理能力：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">chat_completions</span>(<span class="params">request: ChatCompletionRequest, ...</span>):</span><br><span class="line">    client = httpx.AsyncClient(timeout=<span class="number">300</span>)</span><br><span class="line">    response = <span class="keyword">await</span> client.send(req, stream=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-类型安全"><a href="#2-类型安全" class="headerlink" title="2. 类型安全"></a>2. 类型安全</h3><p>使用Pydantic进行数据验证，确保API的类型安全。</p>
<h3 id="3-配置管理"><a href="#3-配置管理" class="headerlink" title="3. 配置管理"></a>3. 配置管理</h3><p>环境变量和配置文件相结合的配置管理策略。</p>
<h3 id="4-容错设计"><a href="#4-容错设计" class="headerlink" title="4. 容错设计"></a>4. 容错设计</h3><p>多层次的异常处理，保证服务的稳定性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个项目虽然代码量不大，但展示了构建API适配器的完整流程：</p>
<ol>
<li><strong>接口设计</strong>: 遵循OpenAI API标准</li>
<li><strong>数据转换</strong>: 灵活处理不同格式的数据</li>
<li><strong>错误处理</strong>: 提供清晰的错误信息</li>
<li><strong>部署优化</strong>: 选择合适的部署平台</li>
<li><strong>安全考虑</strong>: 明确使用范围和风险</li>
</ol>
<p>对于学习FastAPI开发和API适配器设计来说，这是一个很好的实践案例。虽然底层服务的真实性存疑，但技术实现本身还是值得参考的。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>原始项目: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29EYWlTdW5vL3RhbGthaTJhcGk=">oDaiSuno&#x2F;talkai2api<i class="fa fa-external-link-alt"></i></span></li>
<li>参考项目: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmF4dWFuL0N0b0FQaQ==">libaxuan&#x2F;CtoAPi<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<p><em>本文主要用于技术学习和交流，请遵守相关法律法规和服务条款。</em></p>
<img src = "https://media.makomako.dpdns.org/avatar/avatar.jpg" style= "width: auto ">

]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp; LLM</category>
        <category>Interesting</category>
      </categories>
  </entry>
  <entry>
    <title>Ultimate Plan for Gemini API Calls</title>
    <url>/posts/4763/</url>
    <content><![CDATA[<blockquote>
<p>Gemini API Key 终极管理方案</p>
</blockquote>
<span id="more"></span>
<hr>
<h2 id="📋-密钥状态"><a href="#📋-密钥状态" class="headerlink" title="📋 密钥状态"></a>📋 密钥状态</h2><p>Gemini API Key 管理方案，解决 API 调用限制、断流问题以及多账户负载均衡。</p>
<h2 id="🔐-Account-Status"><a href="#🔐-Account-Status" class="headerlink" title="🔐 Account Status"></a>🔐 Account Status</h2><h3 id="当前账户配置"><a href="#当前账户配置" class="headerlink" title="当前账户配置"></a>当前账户配置</h3><ul>
<li><strong>mako</strong>: <code>main, online</code> ✅</li>
<li><strong>grey</strong>: <code>main, online</code> ✅  </li>
<li><strong>fish</strong>: <code>mylove, hidden</code> 🔒</li>
<li><strong>aibots</strong>: <code>deprecated, exposed</code> ❌ (开小号被发现了)</li>
</ul>
<h3 id="账户配额"><a href="#账户配额" class="headerlink" title="账户配额"></a>账户配额</h3><table>
<thead>
<tr>
<th>账户</th>
<th>配额</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>mako</td>
<td>10个</td>
<td>主用</td>
</tr>
<tr>
<td>grey</td>
<td>0个</td>
<td>被ban了</td>
</tr>
<tr>
<td>fish</td>
<td>7个</td>
<td>主用</td>
</tr>
<tr>
<td>打野付费</td>
<td>5个</td>
<td>备用</td>
</tr>
</tbody></table>
<h3 id="反代方案"><a href="#反代方案" class="headerlink" title="反代方案"></a>反代方案</h3><ul>
<li><p>Netlify mako non fish bot03 rexy bangzhu</p>
</li>
<li><p>Vercel  non  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvdmluZ2Zpc2gvcHJveHktaW50ZXJmYWNl">Interface proxy<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvdmluZ2Zpc2gvcGFsbS1uZXRsaWZ5LXByb3h5">palm-netlify-proxy<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h3 id="扩展计划"><a href="#扩展计划" class="headerlink" title="扩展计划"></a>扩展计划</h3><ul>
<li><input disabled="" type="checkbox"> 手机 Google Mail 注册新账户增加 Key 数量</li>
<li><input disabled="" type="checkbox"> Chrome 匿名模式管理小号</li>
<li><input disabled="" type="checkbox"> 避免在非匿名环境中操作小号</li>
<li><input disabled="" type="checkbox"> 幽灵代理，没看明白</li>
<li><input disabled="" type="checkbox"> 扩充反截断方案和部署CF Worker数目</li>
</ul>
<h2 id="🏗️-技术方案"><a href="#🏗️-技术方案" class="headerlink" title="🏗️ 技术方案"></a>🏗️ 技术方案</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Cherry Studio] --&gt; B[Docker GPT-Load]</span><br><span class="line">    B --&gt; A</span><br><span class="line">    B --&gt; C[CloudFlare]</span><br><span class="line">    C --&gt; B</span><br><span class="line">    C --反截断--&gt; D[Netlify]</span><br><span class="line">    D --完整响应--&gt; C</span><br><span class="line">    D --反代--&gt; E[Gemini API]</span><br><span class="line">    E --&gt; D</span><br></pre></td></tr></table></figure>

<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul>
<li><strong>GPT-Load</strong>: 负载均衡和API管理</li>
<li><strong>CloudFlare Worker</strong>: 断流检测和自动续传</li>
<li><strong>Netlify</strong> 反代服务</li>
<li><strong>Docker</strong>: 容器化部署</li>
<li><strong>Google AI API</strong>: 底层服务</li>
</ul>
<h3 id="🔧-详细工作原理"><a href="#🔧-详细工作原理" class="headerlink" title="🔧 详细工作原理"></a>🔧 详细工作原理</h3><h4 id="1-请求流程详解"><a href="#1-请求流程详解" class="headerlink" title="1. 请求流程详解"></a>1. 请求流程详解</h4><p><strong>第一步：Cherry Studio → GPT-Load</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Cherry Studio 发送请求 → Docker 容器中的 GPT-Load 接收</span><br></pre></td></tr></table></figure>

<p><strong>第二步：GPT-Load → CloudFlare Worker</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GPT-Load 根据负载均衡策略选择 API Key</span><br><span class="line">→ 将请求转发到 CloudFlare Worker</span><br><span class="line">→ Worker 作为中间代理层处理请求</span><br></pre></td></tr></table></figure>

<p><strong>第三步：CloudFlare Worker → Netlify</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CloudFlare Worker 携带选定的 API Key</span><br><span class="line">→ 请求Netlify转发响应</span><br></pre></td></tr></table></figure>

<p><strong>第四步：Netlify → Google API</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Netlify 请求 Google API的相应</span><br></pre></td></tr></table></figure>

<p><strong>第五步：反向传播回 CloudFlare</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">→ 实时分析响应内容</span><br><span class="line">→ 检测是否被截断，如果被截断，继续第三步</span><br></pre></td></tr></table></figure>
<h4 id="2-防截断机制-基于-G-E-M-方案"><a href="#2-防截断机制-基于-G-E-M-方案" class="headerlink" title="2. 防截断机制 (基于 G.E.M. 方案)"></a>2. 防截断机制 (基于 G.E.M. 方案)</h4><p><strong>截断检测算法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">detectTruncation</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 检查响应长度是否异常短</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">length</span> &lt; expectedLength) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否以不完整句子结尾</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="title function_">endsWith</span>(<span class="string">&#x27;.&#x27;</span>) &amp;&amp; !response.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>) &amp;&amp; !response.<span class="title function_">endsWith</span>(<span class="string">&#x27;?&#x27;</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 检查是否有截断标记</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="title function_">includes</span>(<span class="string">&#x27;[截断]&#x27;</span>) || response.<span class="title function_">includes</span>(<span class="string">&#x27;...&#x27;</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自动续传流程：</strong></p>
<ol>
<li><strong>检测截断</strong>: Worker 实时监控响应状态</li>
<li><strong>保存上下文</strong>: 保留原始请求的上下文信息</li>
<li><strong>构造续传请求</strong>: 基于截断点构造新的 API 调用</li>
<li><strong>智能拼接</strong>: 将续传内容与原内容无缝拼接</li>
<li><strong>返回完整响应</strong>: 返回给 GPT-Load 再转发给 Cherry Studio</li>
</ol>
<h4 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="3. 负载均衡策略"></a>3. 负载均衡策略</h4><p><strong>GPT-Load 配置示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多账户轮询配置</span></span><br><span class="line"><span class="attr">providers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;myself&quot;</span></span><br><span class="line">    <span class="attr">api_key:</span> <span class="string">&quot;$&#123;MAKO_API_KEY&#125;&quot;</span></span><br><span class="line">    <span class="attr">quota:</span> <span class="number">10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;free&quot;</span> </span><br><span class="line">    <span class="attr">api_key:</span> <span class="string">&quot;$&#123;GREY_API_KEY&#125;&quot;</span></span><br><span class="line">    <span class="attr">quota:</span> <span class="number">7777</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;charge&quot;</span></span><br><span class="line">    <span class="attr">api_key:</span> <span class="string">&quot;$&#123;FISH_API_KEY&#125;&quot;</span></span><br><span class="line">    <span class="attr">quota:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>故障切换机制：</strong></p>
<ul>
<li>账户配额耗尽时自动切换到下一个可用账户</li>
<li>网络异常时重试机制</li>
<li>账户被封禁时自动禁用并告警</li>
</ul>
<h4 id="4-技术实现要点"><a href="#4-技术实现要点" class="headerlink" title="4. 技术实现要点"></a>4. 技术实现要点</h4><p><strong>CloudFlare Worker 核心功能：</strong></p>
<ul>
<li><strong>中间代理</strong>: 作为 GPT-Load 和 Google API 之间的桥梁</li>
<li><strong>自适应混淆</strong>: 动态调整请求参数避免检测</li>
<li><strong>上下文保持</strong>: 在续传过程中保持对话连贯性</li>
<li><strong>错误处理</strong>: 完善的异常处理和重试机制</li>
</ul>
<h2 id="📊-部署进度"><a href="#📊-部署进度" class="headerlink" title="📊 部署进度"></a>📊 部署进度</h2><h3 id="✅-已完成"><a href="#✅-已完成" class="headerlink" title="✅ 已完成"></a>✅ 已完成</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 三个账户配置完成</li>
<li><input checked="" disabled="" type="checkbox"> API配额分配</li>
<li><input checked="" disabled="" type="checkbox"> 基础架构搭建</li>
</ul>
<h3 id="🔄-待完成"><a href="#🔄-待完成" class="headerlink" title="🔄 待完成"></a>🔄 待完成</h3><ul>
<li><input disabled="" type="checkbox"> 手机 Google Mail 注册新账户增加 Key 数量</li>
<li><input disabled="" type="checkbox"> 优化 old 方案，看保留做备用还是直接彻底擦除</li>
<li><input disabled="" type="checkbox"> 其他API如阿里云的配置</li>
</ul>
<h2 id="⚠️-重要提醒"><a href="#⚠️-重要提醒" class="headerlink" title="⚠️ 重要提醒"></a>⚠️ 重要提醒</h2><blockquote>
<p><strong>🚨 关键问题：手机端兼容性</strong></p>
<p><strong>忘记了！</strong> 这个方案是完全给 <strong>LapTop 私密化</strong> 的…</p>
<p><strong>所以必须保留一些原先的服务器管理 API Key 调用方案给手机 ChatBox 使用</strong></p>
</blockquote>
<h2 id="🎯-应用场景分配"><a href="#🎯-应用场景分配" class="headerlink" title="🎯 应用场景分配"></a>🎯 应用场景分配</h2><h3 id="Allocate-策略"><a href="#Allocate-策略" class="headerlink" title="Allocate 策略"></a>Allocate 策略</h3><!--这部分慢慢填写，用的api很多-->

<table>
<thead>
<tr>
<th>应用</th>
<th>方案</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cherry Studio</strong></td>
<td>新方案</td>
<td>调用Gemini的话全部这个方案~~ 其他方案可以先设置为 unseen</td>
</tr>
<tr>
<td><strong>ChatBox</strong></td>
<td>老方案</td>
<td>得用老方案，这个是手机端的</td>
</tr>
<tr>
<td><strong>RooCode etc</strong></td>
<td>废弃</td>
<td>先不动再说，看Cursor和ClaudeCode能否稳定长期使用</td>
</tr>
</tbody></table>
<h3 id="🔍-待考虑的"><a href="#🔍-待考虑的" class="headerlink" title="🔍 待考虑的~"></a>🔍 待考虑的~</h3><p>想起来什么再补充</p>
<ul>
<li>幽灵反代</li>
<li>自建</li>
<li><input disabled="" type="checkbox"> 成本统计和分析</li>
<li><input disabled="" type="checkbox"> 备份和恢复策略</li>
</ul>
<h2 id="📚-Ref"><a href="#📚-Ref" class="headerlink" title="📚 Ref"></a>📚 Ref</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3B0LWxvYWQuY29tLw==">GPT-Load<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kby90L3RvcGljLzc0MTk1Mw==">G.E.M. - 让 Gemini 自动续写被截断的对话【无缝断点续传 | 自适应混淆】<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kby90L3RvcGljLzg2MDE2MS8xMDQ=">完全解决Gemini 断流问题！！！（有点麻，还是有中断）好像修复了？移步新帖讨论<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kby90L3RvcGljLzg2MDMxNg==">[Gemini公益] 防断流v2|已测试 效果不错<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="📝-更新日志"><a href="#📝-更新日志" class="headerlink" title="📝 更新日志"></a>📝 更新日志</h2><ul>
<li>待补充更多更新记录…</li>
<li><strong>2025-08-20</strong> v1，增加稳定反代，扩展反截断</li>
<li><strong>2025-08-12</strong>: 初始版本，基础框架搭建</li>
</ul>
<hr>
<p><em>个人技术记录，持续更新中…</em></p>
]]></content>
      <categories>
        <category>技术记录与分享</category>
        <category>AI &amp; LLM</category>
      </categories>
      <tags>
        <tag>AI-LLM</tag>
        <tag>技术分享</tag>
        <tag>git</tag>
        <tag>gemini</tag>
        <tag>proxy</tag>
        <tag>ai</tag>
        <tag>cloudflare</tag>
        <tag>api</tag>
      </tags>
  </entry>
</search>
